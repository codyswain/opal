Tree structure of src folder:
src
â”œâ”€â”€ main
â”‚Â Â  â”œâ”€â”€ configManager.ts
â”‚Â Â  â”œâ”€â”€ embeddings.ts
â”‚Â Â  â”œâ”€â”€ fileSystem.ts
â”‚Â Â  â”œâ”€â”€ logger.ts
â”‚Â Â  â””â”€â”€ pythonBridge.ts
â”œâ”€â”€ main.ts
â”œâ”€â”€ preload.ts
â”œâ”€â”€ renderer
â”‚Â Â  â”œâ”€â”€ App.tsx
â”‚Â Â  â”œâ”€â”€ config
â”‚Â Â  â”‚Â Â  â””â”€â”€ setup.ts
â”‚Â Â  â”œâ”€â”€ features
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ commands
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ CommandPalette.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useCommands.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ services
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ commandRegistry.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ feed
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Feed.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ fileSystem
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ state
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ types
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ kbar
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ KBar.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ context
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ KBarActionsProvider.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ navbar
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Navbar.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ NavbarItem.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ navbarItems.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useNavbarItems.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ notes
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteEditor
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ MarkdownEditor.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteEditor.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteExplorer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteExplorerContent.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteExplorerContextMenu.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteExplorerHeader.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ Toolbar.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteExplorer
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Notes.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ RightSidebar
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ ChatLocalPane.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ ChatPane.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ RelatedNoteListItem.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ RelatedNotes.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ RightSidebar.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ context
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ notesContext.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ useNoteExplorerContextMenu.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useNotes.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ settings
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ Settings.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ context
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ SettingsContext.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ types
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ utils
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ settingsStorage.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ theme
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ ThemeToggle.tsx
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ config
â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ themeConfig.ts
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ context
â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ ThemeContext.tsx
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ useTheme.ts
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ index.tsx
â”‚Â Â  â”‚Â Â      â””â”€â”€ utils
â”‚Â Â  â”‚Â Â          â””â”€â”€ themeUtils.ts
â”‚Â Â  â”œâ”€â”€ index.css
â”‚Â Â  â”œâ”€â”€ shared
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Button.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Card.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ContextMenu
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ContextMenu.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ContextMenuItem.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DropdownMenu.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ScrollArea.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Tabs
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CustomTabBar.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Tabs.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TabsContent.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TabsList.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TabsTrigger.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Toast.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Toggle.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Tooltip.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ input.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ useDebounce.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ useLocalStorage.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ useResizablePane.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useResizableSidebar.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ types
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ utils
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ cn.ts
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ fileUtils.ts
â”‚Â Â  â”‚Â Â      â””â”€â”€ index.ts
â”‚Â Â  â””â”€â”€ styles
â”‚Â Â      â”œâ”€â”€ GlobalStyles.ts
â”‚Â Â      â”œâ”€â”€ NoteEditor.css
â”‚Â Â      â””â”€â”€ common
â”‚Â Â          â””â”€â”€ components.ts
â””â”€â”€ renderer.tsx

49 directories, 80 files


File contents:

--- src/renderer.tsx ---

import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "@/renderer/App";
import "@/renderer/index.css";
import {
  Note,
  FileNode,
  DirectoryEntry,
  SimilarNote,
  Embedding,
  DirectoryStructures,
} from "@/renderer/shared/types";

declare global {
  interface Window {
    electron: {
      saveNote: (note: Note, dirPath: string) => Promise<string>;
      deleteNote: (noteId: string, dirPath: string) => Promise<void>;
      minimize: () => void;
      maximize: () => void;
      close: () => void;
      getOpenAIKey: () => Promise<string>;
      setOpenAIKey: (key: string) => Promise<void>;
      getNotePath: (noteId: string) => Promise<string>;
      createDirectory: (dirPath: string) => Promise<void>;
      deleteDirectory: (dirPath: string) => Promise<void>;
      getTopLevelFolders: () => Promise<string[]>;
      addTopLevelFolder: (folderPath: string) => Promise<string[]>;
      removeTopLevelFolder: (folderPath: string) => Promise<string[]>;
      openFolderDialog: () => Promise<string | null>;
      getDirectoryStructure: (dirPath: string) => Promise<DirectoryEntry>;
      loadNote: (notePath: string) => Promise<Note>;
      deleteFileNode: (
        fileNodeType: string,
        fileNodePath: string
      ) => Promise<void>;
      generateNoteEmbeddings: (
        note: Note,
        fileNode: FileNode
      ) => Promise<Embedding>;
      findSimilarNotes: (
        query: string,
        directoryStructures: DirectoryStructures
      ) => Promise<SimilarNote[]>;
      performRAGChat: (
        conversation: { role: string; content: string }[],
        directoryStructures: DirectoryStructures
      ) => Promise<{ role: string; content: string }>;
    };
  }
}

createRoot(document.getElementById("root") as HTMLElement).render(
  <StrictMode>
    <App />
  </StrictMode>
);

console.log(
  'ðŸ‘‹ This message is being logged by "renderer.tsx", included via Vite'
);

--- src/renderer/App.tsx ---

import React, { useCallback, useEffect, useMemo, useState } from "react";
import {
  BrowserRouter as Router,
  Route,
  Routes,
  Navigate,
} from "react-router-dom";
import "@/renderer/index.css";

import { ThemeProvider } from "@/renderer/features/theme";
import { NotesProvider } from "@/renderer/features/notes/context/notesContext";
import { TooltipProvider } from "@/renderer/shared/components/Tooltip";
import { Toaster } from "@/renderer/shared/components/Toast";
import { Navbar, navbarItems } from "@/renderer/features/navbar";
import { Notes } from "@/renderer/features/notes";
import { Settings, SettingsProvider } from "@/renderer/features/settings";
import useLocalStorage from "@/renderer/shared/hooks/useLocalStorage";
import { commandRegistry, useCommands } from "@/renderer/features/commands";
import { Command } from "@/renderer/features/commands/services/commandRegistry";
import { KBar, KBarActionsProvider } from "@/renderer/features/kbar";

const App: React.FC = () => {
  const { registerCommand, unregisterCommand } = useCommands();

  const [isLeftSidebarOpen, setIsLeftSidebarOpen] = useLocalStorage(
    "isLeftSidebarOpen",
    true
  );
  const [isRightSidebarOpen, setIsRightSidebarOpen] = useLocalStorage(
    "isRightSidebarOpen",
    true
  );
  const [isBottomPaneOpen, setIsBottomPaneOpen] = useLocalStorage(
    "isBottomPaneOpen",
    true
  );

  const toggleLeftSidebar = useCallback(
    () => setIsLeftSidebarOpen(!isLeftSidebarOpen),
    [isLeftSidebarOpen]
  );
  const toggleRightSidebar = useCallback(
    () => setIsRightSidebarOpen(!isRightSidebarOpen),
    [isRightSidebarOpen]
  );
  const toggleBottomPane = useCallback(
    () => setIsBottomPaneOpen(!isBottomPaneOpen),
    [isBottomPaneOpen]
  );

  useEffect(() => {
    const commands: Command[] = [
      {
        id: "pane.toggleLeft",
        name: "Toggle Left Pane",
        type: "paneToggle",
        keywords: ["pane", "toggle"],
        perform: toggleLeftSidebar,
      },
      {
        id: "pane.toggleRight",
        name: "Toggle Right Pane",
        type: "paneToggle",
        keywords: ["pane", "toggle"],
        perform: toggleRightSidebar,
      },
      {
        id: "pane.toggleBottom",
        name: "Toggle Bottom Pane",
        type: "paneToggle",
        keywords: ["pane", "toggle"],
        perform: toggleBottomPane,
      },
    ];

    commands.forEach(registerCommand);

    return () => {
      commands.forEach((command) => unregisterCommand(command));
    };
  }, [
    registerCommand,
    unregisterCommand,
    toggleLeftSidebar,
    toggleRightSidebar,
    toggleBottomPane,
  ]);

  return (
    <Router>
      <KBarActionsProvider>
        <KBar />
        <ThemeProvider>
          <SettingsProvider>
            <TooltipProvider>
              <NotesProvider>
                <div className="flex flex-col h-screen w-screen overflow-hidden">
                  <Toaster />
                  <div className="flex flex-col flex-grow overflow-hidden">
                    <Navbar
                      toggleLeftSidebar={toggleLeftSidebar}
                      toggleRightSidebar={toggleRightSidebar}
                      toggleBottomPane={toggleBottomPane}
                      isLeftSidebarOpen={isLeftSidebarOpen}
                      isRightSidebarOpen={isRightSidebarOpen}
                      isBottomPaneOpen={isBottomPaneOpen}
                      items={navbarItems}
                    />
                    <main className="flex-grow overflow-hidden mt-12">
                      <Routes>
                        <Route
                          path="/"
                          element={<Navigate to="/notes" replace />}
                        />
                        <Route path="/settings" element={<Settings />} />
                        <Route
                          path="/notes"
                          element={
                            <Notes
                              isLeftSidebarOpen={isLeftSidebarOpen}
                              isRightSidebarOpen={isRightSidebarOpen}
                              setIsLeftSidebarOpen={setIsLeftSidebarOpen}
                              setIsRightSidebarOpen={setIsRightSidebarOpen}
                            />
                          }
                        />
                      </Routes>
                    </main>
                  </div>
                </div>
              </NotesProvider>
            </TooltipProvider>
          </SettingsProvider>
        </ThemeProvider>
      </KBarActionsProvider>
    </Router>
  );
};

export default App;

--- src/renderer/config/setup.ts ---

const DEFAULT_WINDOW_WIDTH = 800;
const DEFAULT_WINDOW_HEIGHT = 600;

export { DEFAULT_WINDOW_WIDTH, DEFAULT_WINDOW_HEIGHT };

--- src/renderer/features/settings/index.tsx ---

export { Settings } from './components/Settings';
export { SettingsProvider, useSettings } from './context/SettingsContext';
export type { Settings as SettingsType, SettingsContextType } from './types';
--- src/renderer/features/settings/types/index.ts ---

export interface Settings {
  openAIKey: string;
}

export interface SettingsContextType {
  settings: Settings;
  updateSettings: (newSettings: Partial<Settings>) => Promise<void>;
}
--- src/renderer/features/settings/context/SettingsContext.tsx ---

import React, { createContext, useContext, useState, useEffect } from 'react';
import { SettingsContextType, Settings } from '../types';
import { getSettings, saveSettings } from '../utils/settingsStorage';

const SettingsContext = createContext<SettingsContextType | undefined>(undefined);

export const SettingsProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [settings, setSettings] = useState<Settings>({
    openAIKey: '',
  });

  useEffect(() => {
    const loadSettings = async () => {
      const savedSettings = await getSettings();
      setSettings(savedSettings);
    };
    loadSettings();
  }, []);

  const updateSettings = async (newSettings: Partial<Settings>) => {
    const updatedSettings = { ...settings, ...newSettings };
    setSettings(updatedSettings);
    await saveSettings(updatedSettings);
  };

  return (
    <SettingsContext.Provider value={{ settings, updateSettings }}>
      {children}
    </SettingsContext.Provider>
  );
};

export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (context === undefined) {
    throw new Error('useSettings must be used within a SettingsProvider');
  }
  return context;
};
--- src/renderer/features/settings/utils/settingsStorage.ts ---

import { Settings } from '../types';

export const getSettings = async (): Promise<Settings> => {
  const openAIKey = await window.electron.getOpenAIKey();
  return { openAIKey: openAIKey || '' };
};

export const saveSettings = async (settings: Settings): Promise<void> => {
  await window.electron.setOpenAIKey(settings.openAIKey);
};
--- src/renderer/features/settings/components/Settings.tsx ---

import React, { useState } from "react";
import { Input } from "@/renderer/shared/components/Input";
import { Button } from "@/renderer/shared/components/Button";
import { Eye, EyeOff } from "lucide-react";
import { useSettings } from "../context/SettingsContext";

export const Settings: React.FC = () => {
  const { settings, updateSettings } = useSettings();
  const [showApiKey, setShowApiKey] = useState(false);

  const handleSave = () => {
    updateSettings({ openAIKey: settings.openAIKey });
  };

  const toggleApiKeyVisibility = () => {
    setShowApiKey(!showApiKey);
  };

  return (
    <div className="container mx-auto mt-2 pt-12 ">
      <h2 className="text-2xl font-bold mb-4">Settings</h2>
      <div className="mb-4">
        <label htmlFor="apiKey" className="block text-sm font-medium mb-1">
          OpenAI API Key
        </label>
        <div className="flex items-center">
          <div className="flex-grow">
            <Input
              id="apiKey"
              type={showApiKey ? "text" : "password"}
              value={settings.openAIKey}
              onChange={(e) => updateSettings({ openAIKey: e.target.value })}
              className="w-full"
              placeholder="Enter your OpenAI API key"
            />
          </div>
          <button
            type="button"
            onClick={toggleApiKeyVisibility}
            className="ml-2 p-2 focus:outline-none"
          >
            {showApiKey ? (
              <EyeOff className="h-5 w-5 text-gray-400" />
            ) : (
              <Eye className="h-5 w-5 text-gray-400" />
            )}
          </button>
        </div>
      </div>
      <Button onClick={handleSave}>Save</Button>
    </div>
  );
};
--- src/renderer/features/navbar/index.tsx ---

import Navbar from './components/Navbar';
import navbarItems from './config/navbarItems';

export {
  Navbar,
  navbarItems
};
--- src/renderer/features/navbar/config/navbarItems.ts ---

import { NavbarItemProps } from "../components/NavbarItem";
import { Home, Notebook } from "lucide-react";

const navbarItems: NavbarItemProps[] = [
  // TODO: add this in
  // { to: "/", icon: Home, text: "Home" },
  { to: "/notes", icon: Notebook, text: "Notes" }
];

export default navbarItems;
--- src/renderer/features/navbar/components/Navbar.tsx ---

import React from "react";
import { Link, useLocation } from "react-router-dom";
import { Button } from "@/renderer/shared/components/Button";
import { NavbarItem, NavbarItemProps } from "./NavbarItem";
import {
  Minus,
  PanelLeftClose,
  PanelLeftOpen,
  PanelRightClose,
  PanelRightOpen,
  Settings,
  Square,
  X,
  ChevronsUp,
  ChevronsDown,
} from "lucide-react";
import { ThemeToggle } from "@/renderer/features/theme";

interface NavbarProps {
  toggleLeftSidebar: () => void;
  toggleRightSidebar: () => void;
  toggleBottomPane: () => void;
  isLeftSidebarOpen: boolean;
  isRightSidebarOpen: boolean;
  isBottomPaneOpen: boolean;
  items: NavbarItemProps[];
}

const Navbar: React.FC<NavbarProps> = ({
  toggleLeftSidebar,
  toggleRightSidebar,
  toggleBottomPane,
  isLeftSidebarOpen,
  isRightSidebarOpen,
  isBottomPaneOpen,
  items,
}) => {
  const location = useLocation();

  const handleWindowAction = (action: "minimize" | "maximize" | "close") => {
    window.electron[action]();
  };

  const renderWindowControls = () => (
    <div className="flex items-center space-x-2 no-drag">
      {[
        { action: "close", icon: X },
        { action: "minimize", icon: Minus },
        { action: "maximize", icon: Square },
      ].map(({ action, icon: Icon }) => (
        <Button
          key={action}
          variant="ghost"
          size="icon"
          className="h-8 w-8"
          onClick={() =>
            handleWindowAction(action as "minimize" | "maximize" | "close")
          }
        >
          <span className="sr-only">{action}</span>
          <Icon className="h-4 w-4 mr-2" />
        </Button>
      ))}
    </div>
  );

  const renderNavItems = () => (
    <ul className="flex items-center space-x-2 no-drag mx-auto">
      {items.map((item) => (
        <NavbarItem
          key={item.to}
          {...item}
          isActive={location.pathname === item.to}
        />
      ))}
    </ul>
  );

  const renderSidebarControls = () => (
    <div className="flex items-center space-x-2 no-drag">
      <ThemeToggle />
      <Button
        variant="ghost"
        size="icon"
        className="h-8 w-8"
        onClick={toggleLeftSidebar}
      >
        {isLeftSidebarOpen ? (
          <PanelLeftClose className="h-4 w-4" />
        ) : (
          <PanelLeftOpen className="h-4 w-4" />
        )}
      </Button>
      <Button
        variant="ghost"
        size="icon"
        className="h-8 w-8"
        onClick={toggleRightSidebar}
      >
        {isRightSidebarOpen ? (
          <PanelRightClose className="h-4 w-4" />
        ) : (
          <PanelRightOpen className="h-4 w-4" />
        )}
      </Button>
      <Button
        variant="ghost"
        size="icon"
        className="h-8 w-8"
        onClick={toggleBottomPane}
      >
        {isBottomPaneOpen ? (
          <ChevronsDown className="h-4 w-4" />
        ) : (
          <ChevronsUp className="h-4 w-4" />
        )}
      </Button>
      <Link to="/settings">
        <Button variant="ghost" size="icon" className="h-8 w-8">
          <Settings className="h-4 w-4" />
        </Button>
      </Link>
    </div>
  );

  return (
    <nav className="fixed top-0 left-0 right-0 h-12 bg-background border-b border-border flex items-center justify-between px-4 z-20 drag-handle">
      {renderWindowControls()}
      {renderNavItems()}
      {renderSidebarControls()}
    </nav>
  );
};

export default Navbar;

--- src/renderer/features/navbar/components/NavbarItem.tsx ---

import React from "react";
import { Link } from "react-router-dom";
import { LucideIcon } from "lucide-react";

export interface NavbarItemProps {
  to: string;
  icon: LucideIcon;
  text: string;
  isActive?: boolean;
}

export const NavbarItem: React.FC<NavbarItemProps> = ({ to, icon: Icon, text, isActive }) => (
  <li>
    <Link
      to={to}
      className={`flex items-center px-3 py-1 rounded-md text-sm ${
        isActive ? "bg-accent text-accent-foreground" : "hover:bg-accent/50"
      }`}
    >
      <Icon className="h-4 w-4 mr-2" />
      {text}
    </Link>
  </li>
);
--- src/renderer/features/navbar/hooks/useNavbarItems.ts ---

import { useMemo } from 'react';
import navbarItems from '../config/navbarItems';

export const useNavbarItems = () => {
  return useMemo(() => navbarItems, []);
};
--- src/renderer/features/notes/index.tsx ---

import Notes from './components/Notes';
import NoteEditor from './components/NoteEditor/NoteEditor';
import RelatedNotes from './components/RightSidebar/RelatedNotes';
import { useNotes } from './hooks/useNotes';

export {
  Notes,
  NoteEditor,
  RelatedNotes,
  useNotes
};
--- src/renderer/features/notes/context/notesContext.tsx ---

// src/features/notes/context/notesContext.tsx

import React, { createContext, useContext, ReactNode } from 'react';
import { useNotes } from '../hooks/useNotes';

const NotesContext = createContext<ReturnType<typeof useNotes> | undefined>(undefined);

export const NotesProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const notesData = useNotes();
  
  return (
    <NotesContext.Provider value={notesData}>
      {children}
    </NotesContext.Provider>
  );
};

export const useNotesContext = () => {
  const context = useContext(NotesContext);
  if (context === undefined) {
    throw new Error('useNotesContext must be used within a NotesProvider');
  }
  return context;
};

--- src/renderer/features/notes/components/NoteEditor/MarkdownEditor.tsx ---

// src/features/notes/components/MarkdownEditor.tsx

import React, { useRef, useState, useEffect } from 'react';
import { cn } from '@/renderer/shared/utils';
import {
  Bold,
  Italic,
  List,
  ListOrdered,
  Code,
  Quote,
  Image as ImageIcon,
  Link as LinkIcon,
  Strikethrough,
  Terminal,
  Heading1,
  Heading2,
  Heading3,
  Minus,
} from 'lucide-react';
import { Tooltip, TooltipTrigger, TooltipContent } from '@/shared/components/Tooltip';
import { Button } from '@/shared/components/Button';

interface MarkdownEditorProps {
  value: string;
  onChange: (value: string) => void;
}

const MarkdownEditor: React.FC<MarkdownEditorProps> = ({ value, onChange }) => {
  const textAreaRef = useRef<HTMLTextAreaElement>(null);
  const [cursorPosition, setCursorPosition] = useState(0);

  useEffect(() => {
    const textarea = textAreaRef.current;
    if (textarea) {
      textarea.selectionStart = cursorPosition;
      textarea.selectionEnd = cursorPosition;
    }
  }, [cursorPosition]);

  const insertAtCursor = (
    beforeText: string,
    afterText = '',
    defaultText = '',
    cursorAdjustment = 0
  ) => {
    const textarea = textAreaRef.current;
    if (!textarea) return;

    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = value.substring(start, end) || defaultText;

    const newText =
      value.substring(0, start) +
      beforeText +
      selectedText +
      afterText +
      value.substring(end);

    onChange(newText);

    // Update cursor position after insertion
    const newCursorPosition = start + beforeText.length + selectedText.length + cursorAdjustment;
    setCursorPosition(newCursorPosition);

    textarea.focus();
  };

  // Toolbar action handlers
  const handleBold = () => {
    insertAtCursor('**', '**', 'bold text');
  };

  const handleItalic = () => {
    insertAtCursor('*', '*', 'italic text');
  };

  const handleUnderline = () => {
    insertAtCursor('<u>', '</u>', 'underlined text');
  };

  const handleStrikethrough = () => {
    insertAtCursor('~~', '~~', 'strikethrough text');
  };

  const handleCode = () => {
    insertAtCursor('`', '`', 'code');
  };

  const handleCodeBlock = () => {
    insertAtCursor('\n```\n', '\n```\n', 'code block', -4);
  };

  const handleBlockquote = () => {
    insertAtCursor('\n> ', '', 'quote');
  };

  const handleUnorderedList = () => {
    insertAtCursor('\n- ', '', 'list item');
  };

  const handleOrderedList = () => {
    insertAtCursor('\n1. ', '', 'list item');
  };

  const handleImage = () => {
    insertAtCursor('![Alt text](', ')', 'image_url');
  };

  const handleLink = () => {
    insertAtCursor('[', '](url)', 'link text');
  };

  const handleHeading = (level: number) => {
    const hashes = '#'.repeat(level);
    insertAtCursor(`\n${hashes} `, '', `Heading ${level}`);
  };

  const handleHorizontalRule = () => {
    insertAtCursor('\n---\n', '', '');
  };

  const toolbarButtons = [
    { icon: Bold, action: handleBold, label: 'Bold' },
    { icon: Italic, action: handleItalic, label: 'Italic' },
    { icon: Strikethrough, action: handleStrikethrough, label: 'Strikethrough' },
    { icon: LinkIcon, action: handleLink, label: 'Link' },
    { icon: ImageIcon, action: handleImage, label: 'Image' },
    { icon: Code, action: handleCode, label: 'Inline Code' },
    { icon: Terminal, action: handleCodeBlock, label: 'Code Block' },
    { icon: Quote, action: handleBlockquote, label: 'Blockquote' },
    { icon: List, action: handleUnorderedList, label: 'Unordered List' },
    { icon: ListOrdered, action: handleOrderedList, label: 'Ordered List' },
    { icon: Heading1, action: () => handleHeading(1), label: 'Heading 1' },
    { icon: Heading2, action: () => handleHeading(2), label: 'Heading 2' },
    { icon: Heading3, action: () => handleHeading(3), label: 'Heading 3' },
    { icon: Minus, action: handleHorizontalRule, label: 'Horizontal Rule' },
  ];

  return (
    <div className="flex flex-col h-full">
      {/* Toolbar */}
      <div className="flex flex-wrap gap-2 mb-2">
        {toolbarButtons.map(({ icon: Icon, action, label }) => (
          <Tooltip key={label}>
            <TooltipTrigger asChild>
              <Button
                variant="outline"
                size="icon"
                onClick={action}
                aria-label={label}
              >
                <Icon className="h-4 w-4" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>{label}</p>
            </TooltipContent>
          </Tooltip>
        ))}
      </div>

      {/* Editor */}
      <textarea
        ref={textAreaRef}
        className="w-full h-full border border-gray-300 p-2 focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-md resize-none overflow-auto bg-background text-foreground"
        value={value}
        onChange={(e) => onChange(e.target.value)}
      />
    </div>
  );
};

export default MarkdownEditor;

--- src/renderer/features/notes/components/NoteEditor/NoteExplorer.tsx ---

import React from "react";
import { Settings } from "lucide-react";
import { Button } from "@/renderer/shared/components/Button";
import { toast } from "@/renderer/shared/components/Toast";
import { useNoteExplorerContextMenu } from "../../hooks/useNoteExplorerContextMenu";
import { NoteExplorerHeader } from "./NoteExplorerHeader";
import NoteExplorerContextMenu from "./NoteExplorerContextMenu";
import { NoteExplorerContent } from "./NoteExplorerContent";
import { useNotesContext } from "../../context/notesContext";

interface NoteExplorerProps {
  isOpen: boolean;
  onClose: () => void;
}

const NoteExplorer: React.FC<NoteExplorerProps> = ({ isOpen, onClose }) => {
  const { contextMenu, handleContextMenu, closeContextMenu } = useNoteExplorerContextMenu();
  const {
    directoryStructures,
    createNote,
    activeFileNode,
    setActiveFileNode,
    deleteFileNode,
    handleCreateFolder,
    isLoading,
    error
  } = useNotesContext();                              

  const handleDelete = () => {
    if (contextMenu?.fileNode) {
      deleteFileNode(contextMenu.fileNode)
    }
  }

  return (
    <div className="h-full flex flex-col bg-background border-r border-border">
      <NoteExplorerContextMenu
        contextMenu={contextMenu}
        onClose={closeContextMenu}
        onDelete={handleDelete}
        onCopyFilePath={() => {console.log('IMPLEMENT COPY FILE PATH')}}
        onOpenNoteInNewTab={() => {console.log('IMPLEMENT OPEN NOTE IN NEW TAB')}}
      />
      <NoteExplorerHeader
        onCreateNote={() => createNote(activeFileNode?.fullPath || "/")}
        onCreateFolder={() => handleCreateFolder(activeFileNode || null)}
      />
      <NoteExplorerContent
        isLoadingFolders={isLoading}
        loadError={error}
        directoryStructures={directoryStructures}
        selectedFileNode={activeFileNode}
        onSelectNote={setActiveFileNode}
        handleContextMenu={handleContextMenu}
      />
      <div className="mt-auto p-2">
        <Button
          variant="ghost"
          size="icon"
          className="h-8 w-8"
          onClick={() => toast("Settings feature is not implemented yet")}
          title="Settings"
        >
          <Settings className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
};

export default NoteExplorer;
--- src/renderer/features/notes/components/NoteEditor/Toolbar.tsx ---

import React from 'react';
import { Editor } from '@tiptap/react';
import {
  Bold,
  Italic,
  Strikethrough,
  Code,
  List,
  ListOrdered,
  Quote,
  Code2,
  Heading1,
  Heading2,
  Heading3,
  ChevronDown,
} from 'lucide-react';
import { cn } from '@/renderer/shared/utils';
import { Button } from '@/renderer/shared/components/Button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/renderer/shared/components/DropdownMenu';

interface ToolbarProps {
  editor: Editor | null;
}

const Toolbar: React.FC<ToolbarProps> = ({ editor }) => {
  if (!editor) {
    return null;
  }

  const buttonClass = (isActive: boolean) =>
    cn(
      'p-2 rounded-md',
      isActive
        ? 'bg-primary text-primary-foreground'
        : 'hover:bg-accent hover:text-accent-foreground'
    );

  const setLanguage = (language: string) => {
    editor.chain().focus().toggleCodeBlock({ language }).run();
  };

  const LANGUAGES = [
    { label: 'Plain Text', value: 'plaintext' },
    { label: 'JavaScript', value: 'js' },
    { label: 'TypeScript', value: 'typescript' },
    { label: 'Python', value: 'python' },
    { label: 'HTML', value: 'html' },
    { label: 'CSS', value: 'css' },
    { label: 'JSON', value: 'json' },
    { label: 'Markdown', value: 'markdown' },
    { label: 'SQL', value: 'sql' },
    { label: 'Bash', value: 'bash' }
  ];

  return (
    <div className="flex items-center space-x-1 mb-4 bg-muted/50 p-2 rounded-md max-w-4xl w-full">
      <Button
        onClick={() => editor.chain().focus().toggleBold().run()}
        className={buttonClass(editor.isActive('bold'))}
        variant="ghost"
        size="icon"
      >
        <Bold className="h-4 w-4" />
      </Button>
      <Button
        onClick={() => editor.chain().focus().toggleItalic().run()}
        className={buttonClass(editor.isActive('italic'))}
        variant="ghost"
        size="icon"
      >
        <Italic className="h-4 w-4" />
      </Button>
      <Button
        onClick={() => editor.chain().focus().toggleStrike().run()}
        className={buttonClass(editor.isActive('strike'))}
        variant="ghost"
        size="icon"
      >
        <Strikethrough className="h-4 w-4" />
      </Button>
      <Button
        onClick={() => editor.chain().focus().toggleCode().run()}
        className={buttonClass(editor.isActive('code'))}
        variant="ghost"
        size="icon"
      >
        <Code className="h-4 w-4" />
      </Button>
      <div className="border-l border-gray-300 dark:border-gray-600 h-6 mx-2" />
      <Button
        onClick={() => editor.chain().focus().toggleBulletList().run()}
        className={buttonClass(editor.isActive('bulletList'))}
        variant="ghost"
        size="icon"
      >
        <List className="h-4 w-4" />
      </Button>
      <Button
        onClick={() => editor.chain().focus().toggleOrderedList().run()}
        className={buttonClass(editor.isActive('orderedList'))}
        variant="ghost"
        size="icon"
      >
        <ListOrdered className="h-4 w-4" />
      </Button>
      <div className="border-l border-gray-300 dark:border-gray-600 h-6 mx-2" />
      <Button
        onClick={() => editor.chain().focus().toggleBlockquote().run()}
        className={buttonClass(editor.isActive('blockquote'))}
        variant="ghost"
        size="icon"
      >
        <Quote className="h-4 w-4" />
      </Button>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button
            className={buttonClass(editor.isActive('codeBlock'))}
            variant="ghost"
            size="icon"
          >
            <Code2 className="h-4 w-4" />
            <ChevronDown className="h-3 w-3 ml-1" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent>
          {LANGUAGES.map(({ label, value }) => (
            <DropdownMenuItem
              key={value}
              onClick={() => editor.chain().focus().toggleCodeBlock({ language: value }).run()}
              className={editor.isActive('codeBlock', { language: value }) ? 'bg-accent' : ''}
            >
              {label}
            </DropdownMenuItem>
          ))}
        </DropdownMenuContent>
      </DropdownMenu>
      <div className="border-l border-gray-300 dark:border-gray-600 h-6 mx-2" />
      <Button
        onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}
        className={buttonClass(editor.isActive('heading', { level: 1 }))}
        variant="ghost"
        size="icon"
      >
        <Heading1 className="h-4 w-4" />
      </Button>
      <Button
        onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
        className={buttonClass(editor.isActive('heading', { level: 2 }))}
        variant="ghost"
        size="icon"
      >
        <Heading2 className="h-4 w-4" />
      </Button>
      <Button
        onClick={() => editor.chain().focus().toggleHeading({ level: 3 }).run()}
        className={buttonClass(editor.isActive('heading', { level: 3 }))}
        variant="ghost"
        size="icon"
      >
        <Heading3 className="h-4 w-4" />
      </Button>
    </div>
  );
};

export default Toolbar;
--- src/renderer/features/notes/components/NoteEditor/NoteExplorerContent.tsx ---

// src/features/notes/components/NoteExplorerContent.tsx

import React, { useEffect, useRef } from "react";
import { ScrollArea } from "@/renderer/shared/components/ScrollArea";
import { Loader, ChevronDown, ChevronRight, Folder, File } from "lucide-react";
import { Input } from "@/renderer/shared/components/input";
import { Button } from "@/renderer/shared/components/Button";
import { cn } from "@/renderer/shared/utils";
import { DirectoryStructures, FileNode } from "@/renderer/shared/types";
import { useNotesContext } from "../../context/notesContext";

interface NoteExplorerContentProps {
  isLoadingFolders: boolean;
  loadError: string | null;
  directoryStructures: DirectoryStructures;
  selectedFileNode: FileNode | null;
  onSelectNote: (file: FileNode) => void;
  handleContextMenu: (
    e: React.MouseEvent,
    fileNode: FileNode
  ) => void;
}

export const NoteExplorerContent: React.FC<NoteExplorerContentProps> = ({
  isLoadingFolders,
  loadError,
  directoryStructures,
  selectedFileNode,
  onSelectNote,
  handleContextMenu,
}) => {
  const { toggleDirectory, expandedDirs, setActiveFileNodeId, activeFileNodeId } = useNotesContext();
  const { newFolderState } = useNotesContext();

  const activeFileNode = activeFileNodeId ? directoryStructures.nodes[activeFileNodeId] : null;

  // For the folder that renders when creating a new folder
  const newFolderInputRef = useRef<HTMLInputElement>(null);
  useEffect(() => {
    if (newFolderState.isCreatingFolder) {
      newFolderInputRef.current?.focus();
    }
  }, [newFolderState.isCreatingFolder]);
  const handleNewFolderKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      newFolderState.confirmCreateFolder();
    } else if (e.key === 'Escape') {
      newFolderState.cancelCreateFolder();
    }
  };

  const renderFileNode = (nodeId: string, depth = 0) => {
    const node = directoryStructures.nodes[nodeId];
    if (!node) return null;

    const isExpanded = expandedDirs.has(node.id);
    const isSelected = selectedFileNode?.id === node.id;

    // Add a container with relative positioning and the vertical line
    const nodeContainer = (content: React.ReactNode) => (
      <div className="relative" key={node.id}>
        {depth > 0 && (
          <div 
            className="absolute border-l border-muted-foreground/20" 
            style={{ 
              left: (depth - 1) * 16 + 8,
              top: 0,
              bottom: 0,
            }}
          />
        )}
        {content}
      </div>
    );

    if (node.type === "directory") {
      return nodeContainer(
        <div>
          <div
            className="flex items-center cursor-pointer hover:bg-accent/50 py-1 px-2"
            style={{ marginLeft: depth * 16 }}
            onClick={(e) => {
              e.preventDefault();
              e.stopPropagation();
              toggleDirectory(node);
            }}
            onContextMenu={(e) => handleContextMenu(e, node)}
          >
            {isExpanded ? (
              <ChevronDown className="h-4 w-4 mr-1" />
            ) : (
              <ChevronRight className="h-4 w-4 mr-1" />
            )}
            {/* <Folder className="h-4 w-4 mr-1" /> */}
            <span>{node.name}</span>
          </div>
          {isExpanded && node.childIds && node.childIds.map((childId) => renderFileNode(childId, depth + 1))}
          {newFolderState.isCreatingFolder &&
            selectedFileNode?.id === node.id && (
              <div className="ml-4 px-2 py-1">
                <Input
                  variant="minimal"
                  ref={newFolderInputRef}
                  value={newFolderState.newFolderName}
                  onChange={(e) => newFolderState.setNewFolderName(e.target.value)}
                  onKeyDown={handleNewFolderKeyDown}
                  onBlur={newFolderState.cancelCreateFolder}
                  placeholder="New folder name"
                  className="w-full"
                />
              </div>
            )}
        </div>
      );
    } else if (node.type === "note") {
      return nodeContainer(
        <div
          className={cn(
            "flex items-center py-1 px-2 rounded-md cursor-pointer text-sm",
            isSelected
              ? "bg-accent text-accent-foreground"
              : "hover:bg-accent/50"
          )}
          style={{ marginLeft: depth * 16 }}
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            setActiveFileNodeId(node.id);
          }}
          onContextMenu={(e) => {
            e.preventDefault();
            e.stopPropagation();
            handleContextMenu(e, node);
          }}
        >
          <span className="truncate">{node.name}</span>
        </div>
      );
    }
    return null;
  };

  return (
    <ScrollArea className="h-[calc(100%-2.5rem)]">
      {newFolderState.error && (
        <div className="text-red-500 text-sm p-2">{newFolderState.error}</div>
      )}
      <div className="p-2">
        {isLoadingFolders ? (
          <div className="flex items-center justify-center h-20">
            <Loader className="h-6 w-6 animate-spin" />
          </div>
        ) : loadError ? (
          <div className="text-red-500 text-sm p-2">{loadError}</div>
        ) : directoryStructures.rootIds.length === 0 ? (
          <div className="text-sm text-muted-foreground p-2">
            No folders added yet.
          </div>
        ) : (
          directoryStructures.rootIds.map((rootId) => renderFileNode(rootId))
        )}
      </div>
    </ScrollArea>
  );
};

--- src/renderer/features/notes/components/NoteEditor/NoteEditor.tsx ---

import React, { useState, useEffect, useCallback } from "react";
import { toast } from "@/renderer/shared/components/Toast";
import {cn} from '@/renderer/shared/utils/cn'
import { Loader2 } from "lucide-react";
import { Input } from "@/renderer/shared/components/Input";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/renderer/shared/components/Tooltip";
import { Note } from "@/renderer/shared/types";
import { useNotesContext } from "../../context/notesContext";
import { useDebouncedCallback } from "use-debounce";
import "katex/dist/katex.min.css";
import { EditorContent, useEditor } from "@tiptap/react";
import { StarterKit } from "@tiptap/starter-kit";
import { Markdown } from "tiptap-markdown";
import { Placeholder } from "@tiptap/extension-placeholder";
import { CodeBlockLowlight } from "@tiptap/extension-code-block-lowlight";
import { createLowlight } from "lowlight";
import js from "highlight.js/lib/languages/javascript";
import python from "highlight.js/lib/languages/python";
import css from "highlight.js/lib/languages/css";
import "highlight.js/styles/github-dark.css";
import Toolbar from "../Toolbar";
import { BulletList } from '@tiptap/extension-bullet-list'
import { OrderedList } from '@tiptap/extension-ordered-list'
import { ListItem } from '@tiptap/extension-list-item'

const lowlight = createLowlight();
lowlight.register("js", js);
lowlight.register("python", python);
lowlight.register("css", css);
lowlight.register('typescript', js);
lowlight.register('html', js);
lowlight.register('json', js);
lowlight.register('markdown', js);
lowlight.register('sql', js);
lowlight.register('bash', js);

const USE_TABS = true; 
const SPACES_PER_TAB = 4;


interface NoteEditorProps {
  note: Note;
}

import '@/renderer/styles/NoteEditor.css'
import { EditorView } from "@tiptap/pm/view";

const NoteEditor: React.FC<NoteEditorProps> = ({ note }) => {
  const { saveNote, createEmbedding } = useNotesContext();

  const [localNote, setLocalNote] = useState(note);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isGeneratingEmbedding, setIsGeneratingEmbedding] = useState(false);
  const [indicatorStatus, setIndicatorStatus] = useState<"green" | "yellow">("green");

  useEffect(() => {
    setLocalNote(note);
    if (editor && note.content !== editor.getHTML()) {
      editor.commands.setContent(note.content || "");
    }
  }, [note]);

  const debouncedSaveContent = useDebouncedCallback(
    async (updatedNote: Note) => {
      setIsSaving(true);
      try {
        await saveNote(updatedNote);
        setError(null);
        setIndicatorStatus("green");
      } catch (err) {
        setError("Failed to save note. Please try again.");
        toast("Error saving note", {
          description: "An error occurred while saving the note. Please try again.",
        });
      } finally {
        setIsSaving(false);
      }
    },
    1000,
    { leading: false, trailing: true }
  );

  const handleTitleChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      const newTitle = e.target.value;
      setLocalNote((prev) => ({ ...prev, title: newTitle }));
      setIndicatorStatus("yellow");
      debouncedSaveContent({ ...localNote, title: newTitle });
    },
    [localNote, debouncedSaveContent]
  );

  const debouncedGenerateEmbedding = useDebouncedCallback(
    async () => {
      setIsGeneratingEmbedding(true);
      try {
        const success = await createEmbedding();
        if (success) {
          console.log("Embedding generated successfully");
        } else {
          console.error("Failed to generate embedding");
        }
      } catch (error) {
        console.error("Error generating embedding:", error);
      } finally {
        setIsGeneratingEmbedding(false);
      }
    },
    5000,
    { leading: false, trailing: true }
  );

  const handleContentChange = useCallback(
    ({ editor }: { editor: any }) => {
      const content = editor.getHTML();
      setLocalNote((prev) => {
        if (prev.content !== content) {
          const updatedNote = { ...prev, content };
          setIndicatorStatus("yellow");
          debouncedSaveContent(updatedNote);
          debouncedGenerateEmbedding();
          return updatedNote;
        }
        return prev;
      });
    },
    [debouncedSaveContent, debouncedGenerateEmbedding]
  );

  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        codeBlock: false,
        bulletList: false,
        orderedList: false,
        listItem: false,
      }),
      CodeBlockLowlight.configure({
        lowlight,
        defaultLanguage: 'plaintext',
      }),
      Markdown,
      Placeholder.configure({
        placeholder: "Start typing your note...",
      }),
      BulletList.configure({
        keepMarks: true,
        keepAttributes: false,
        
      }),
      OrderedList.configure({
        keepMarks: true,
        keepAttributes: false,
        itemTypeName: 'listItem',
        HTMLAttributes: {
          class: 'ordered-list',
        },
      }),
      ListItem
    ],
    content: localNote.content || "",
    onUpdate: handleContentChange,
    autofocus: true,
    editorProps: {
      attributes: {
        class: "prose prose-md dark:prose-invert focus:outline-none max-w-none h-full w-full overflow-auto leading-normal cursor-text",
      },
      handleKeyDown: (view: EditorView, event: KeyboardEvent): boolean => {
        if (event.key === 'Tab') {
          event.preventDefault();
          if (event.shiftKey) {
            // Outdent (move left) when Shift+Tab is pressed
            if (editor?.commands.liftListItem('listItem')) {
              return true;
            }
            // If not in a list, remove indentation (not implemented)
            return false;
          } else {
            // Indent (move right) when Tab is pressed
            if (editor?.commands.sinkListItem('listItem')) {
              return true;
            }
            // If not in a list, add indentation
            const { from, to } = editor.state.selection;
            const indentation = USE_TABS ? '\t' : ' '.repeat(SPACES_PER_TAB);
            editor.chain()
              .focus()
              .insertContent({ type: 'text', text: indentation })
              .setTextSelection(from + indentation.length)
              .run();
            return true;
          }
        }
        return false;
      },
    },
  });

  return (
    <div className="flex flex-col h-full bg-background text-foreground overflow-hidden p-4">
      <div className="flex w-full justify-center items-center">
        <div className="flex items-center justify-between mb-4 w-full max-w-4xl">
          <div className="flex items-center flex-grow mr-2">
            <Input
              type="text"
              value={localNote.title}
              onChange={handleTitleChange}
              placeholder="Note Title"
              className="text-2xl font-semibold border-none focus:ring-0 bg-background text-foreground flex-grow"
              aria-label="Note title"
            />
            {isSaving && <Loader2 className="h-4 w-4 animate-spin ml-2 text-muted-foreground" />}
          </div>
          <div className="flex items-center space-x-2 mr-4">
            {isGeneratingEmbedding && (
              <Tooltip>
                <TooltipTrigger asChild>
                  <div className="h-10 w-10 flex items-center justify-center">
                    <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
                  </div>
                </TooltipTrigger>
                <TooltipContent>
                  <p>Generating embedding...</p>
                </TooltipContent>
              </Tooltip>
            )}

            <Tooltip>
              <TooltipTrigger asChild>
                <div
                  className={cn(
                    "w-2 h-2 rounded-full",
                    indicatorStatus === "green"
                      ? "bg-primary"
                      : "bg-secondary animate-pulse"
                  )}
                />
              </TooltipTrigger>
              <TooltipContent>
                <p>
                  {indicatorStatus === "green"
                    ? "Embedding up to date"
                    : "Embedding needs update"}
                </p>
              </TooltipContent>
            </Tooltip>
          </div>
        </div>

      </div>

      <div className="flex w-full justify-center items-center">
        <Toolbar editor={editor} />
      </div>
      <div
        className="flex-grow overflow-auto"
        onClick={() => {
          if (editor) {
            editor.chain().focus().run();
          }
        }}
      >
        <div className="min-h-full max-w-4xl mx-auto px-6 py-2 bg-card text-card-foreground rounded-lg shadow-lg">
          <EditorContent editor={editor}/>
        </div>
      </div>
      {error && <div className="text-destructive mt-2">{error}</div>}
    </div>
  );
};

export default NoteEditor;
--- src/renderer/features/notes/components/NoteEditor/NoteExplorerHeader.tsx ---

import React from "react";
import { Button } from "@/renderer/shared/components/Button";
import { Pencil, FolderPlus, Plus } from "lucide-react";
import { useNotesContext } from "../../context/notesContext";

interface NoteExplorerHeaderProps {
  onCreateNote: () => void;
  onCreateFolder: () => void;
}

export const NoteExplorerHeader: React.FC<NoteExplorerHeaderProps> = ({
  onCreateNote,
  onCreateFolder,
}) => {
  
  const {
    openDialogToMountDirpath
  } = useNotesContext();

  return (
    <div className="flex justify-between items-center p-2 h-10 border-b border-border">
      <span className="font-semibold text-sm">Files</span>
      <div className="flex">
        {/* TODO: implement */}
        {/* <Button
          variant="ghost"
          size="icon"
          className="h-8 w-8 mr-1"
          onClick={onCreateNote}
          title="New Note"
        >
          <Pencil className="h-4 w-4" />
        </Button> */}
        {/* <Button
          variant="ghost"
          size="icon"
          className="h-8 w-8 mr-1"
          onClick={onCreateFolder}
          title="New Folder"
        >
          <FolderPlus className="h-4 w-4" />
        </Button> */}
        <Button
          variant="ghost"
          size="icon"
          className="h-8 w-8"
          onClick={openDialogToMountDirpath}
          title="Add Top-Level Folder"
        >
          <FolderPlus className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
};
--- src/renderer/features/notes/components/NoteEditor/NoteExplorerContextMenu.tsx ---

// src/features/notes/components/NoteExplorerContextMenu.tsx

import React from "react";
import ContextMenu from "@/renderer/shared/components/ContextMenu/ContextMenu";
import ContextMenuItem from "@/renderer/shared/components/ContextMenu/ContextMenuItem";
import {
  FilePlus,
  FolderPlus,
  Trash2,
  Copy,
  Folder,
  Pencil,
} from "lucide-react";
import { FileNode } from "@/renderer/shared/types";
import { useNotesContext } from "../../context/notesContext";

interface NoteExplorerContextMenuProps {
  contextMenu: {
    x: number;
    y: number;
    fileNode: FileNode;
  } | null;
  onClose: () => void;
  onDelete: () => void;
  onCopyFilePath: (fileNode: FileNode) => void;
  onOpenNoteInNewTab: (fileNode: FileNode) => void;
}

const NoteExplorerContextMenu: React.FC<NoteExplorerContextMenuProps> = ({
  contextMenu,
  onClose,
  onDelete,
  onCopyFilePath,
  onOpenNoteInNewTab,
}) => {
  const { handleCreateFolder, createNote } = useNotesContext();
  if (!contextMenu) return null;
  const { x, y, fileNode } = contextMenu;

  return (
    <ContextMenu x={x} y={y} onClose={onClose}>
      {(fileNode.type === "directory") && (
        <>
          <ContextMenuItem
            icon={FilePlus}
            label="New File"
            onClick={() => {
              createNote(fileNode.fullPath);
              onClose();
            }}
          />
          <ContextMenuItem
            icon={FolderPlus}
            label="New Folder"
            onClick={() => {
              handleCreateFolder(fileNode);
              onClose();
            }}
          />
        </>
      )}
      <ContextMenuItem
        icon={Trash2}
        label="Delete"
        onClick={() => {
          onDelete();
          onClose();
        }}
        className="text-destructive"
      />
      {fileNode.type === "note" && (
        <>
          <ContextMenuItem
            icon={Copy}
            label="Copy ID"
            onClick={() => {
              navigator.clipboard.writeText(fileNode.noteMetadata?.id || "");
              onClose();
            }}
          />
          <ContextMenuItem
            icon={Folder}
            label="Copy File Path"
            onClick={() => {
              onCopyFilePath(fileNode);
              onClose();
            }}
          />
          <ContextMenuItem
            icon={Pencil}
            label="Open in New Tab"
            onClick={() => {
              onOpenNoteInNewTab(fileNode);
              onClose();
            }}
          />
        </>
      )}
    </ContextMenu>
  );
};

export default NoteExplorerContextMenu;

--- src/renderer/features/notes/components/RightSidebar/ChatPane.tsx ---

import React, { useRef, useEffect } from "react";
import { cn } from "@/renderer/shared/utils";
import { ScrollArea } from "@/renderer/shared/components/ScrollArea";
import { Button } from "@/renderer/shared/components/Button";
import { Input } from "@/renderer/shared/components/Input";
import { Settings, Send } from "lucide-react";
import { toast } from "@/renderer/shared/components/Toast";
import { useNotesContext } from "../../context/notesContext";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";

interface BottomPaneProps {
  onClose: () => void;
}

interface Message {
  role: "user" | "assistant";
  content: string;
}

const ChatPane: React.FC<BottomPaneProps> = ({ onClose }) => {
  const [messages, setMessages] = React.useState<Message[]>([]);
  const [input, setInput] = React.useState("");
  const [isLoading, setIsLoading] = React.useState(false);
  const scrollAreaRef = useRef<HTMLDivElement>(null);

  const { performRAGChat, openNoteById } = useNotesContext();

  useEffect(() => {
    if (scrollAreaRef.current) {
      scrollAreaRef.current.scrollTop = scrollAreaRef.current.scrollHeight;
    }
  }, [messages]);

  const handleSend = async () => {
    if (!input.trim()) return;
    const userMessage: Message = { role: "user", content: input.trim() };
    setMessages((prev) => [...prev, userMessage]);
    setInput("");
    setIsLoading(true);
    try {
      const assistantMessage = await performRAGChat([...messages, userMessage]);
      setMessages((prev) => [...prev, assistantMessage as Message]);
    } catch (error) {
      console.error("Error in RAG Chat:", error);
      toast.error("Failed to get response. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  const renderMessage = (message: Message, index: number) => (
    <div
      key={index}
      className={cn(
        "mb-4",
        message.role === "user" ? "text-right" : "text-left"
      )}
    >
      <div
        className={cn(
          "inline-block px-4 py-2 rounded-md",
          message.role === "user"
            ? "bg-primary text-primary-foreground"
            : "bg-secondary text-secondary-foreground"
        )}
      >
        <ReactMarkdown
          remarkPlugins={[remarkGfm]}
          components={{
            a: ({ href, children, ...props }) => {
              if (href?.startsWith("note://")) {
                const noteId = href.replace("note://", "");
                return (
                  <a
                    href="#"
                    onClick={(e) => {
                      e.preventDefault();
                      openNoteById(noteId);
                    }}
                    {...props}
                  >
                    {children}
                  </a>
                );
              }
              return (
                <a href={href} target="_blank" rel="noopener noreferrer" {...props}>
                  {children}
                </a>
              );
            },
          }}
        >
          {message.content}
        </ReactMarkdown>
      </div>
    </div>
  );

  const renderLoader = () => (
    <div className="mb-4 text-left">
      <div className="inline-block px-4 py-2 rounded-md bg-secondary text-secondary-foreground">
        <div className="flex space-x-2">
          <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce" style={{ animationDelay: '0s' }}></div>
          <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
          <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce" style={{ animationDelay: '0.4s' }}></div>
        </div>
      </div>
    </div>
  );

  return (
    <div className="flex flex-col h-full">
      <ScrollArea className="flex-grow px-4" ref={scrollAreaRef}>
        <div className="py-4 space-y-4">
          {messages.map(renderMessage)}
          {isLoading && renderLoader()}
        </div>
      </ScrollArea>
      <div className="border-t border-border p-4">
        <div className="flex items-center gap-2">
          <Input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                handleSend();
              }
            }}
            placeholder="Type your message..."
            className="flex-grow"
          />
          <Button
            onClick={handleSend}
            disabled={isLoading || !input.trim()}
            size="icon"
          >
            <Send className="h-4 w-4" />
          </Button>
        </div>
      </div>
    </div>
  );
};

export default ChatPane;

--- src/renderer/features/notes/components/RightSidebar/RelatedNoteListItem.tsx ---

import React from "react";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/renderer/shared/components/Tooltip";
import { SimilarNote } from "@/renderer/shared/types";
import { Target } from "lucide-react";

const getScoreColor = (score: number): string => {
  if (score >= 0.9) return "text-emerald-600 dark:text-emerald-400";
  if (score >= 0.8) return "text-green-600 dark:text-green-400";
  if (score >= 0.7) return "text-yellow-600 dark:text-yellow-400";
  if (score >= 0.6) return "text-orange-600 dark:text-orange-400";
  return "text-red-600 dark:text-red-400";
};

const stripHtmlTags = (content: string): string => {
  return content.replace(/<[^>]*>/g, "");
};

const truncateContent = (content: string, maxLength: number): string => {
  if (content.length <= maxLength) return content;
  return content.slice(0, maxLength) + "...";
};

const ScoreTooltip: React.FC<{ score: number }> = ({ score }) => (
  <TooltipProvider>
    <Tooltip>
      <TooltipTrigger>
        <span
          className={`text-sm font-medium flex items-center flex-shrink-0 ${getScoreColor(
            score
          )}`}
        >
          <Target className="h-3 w-3 mr-1 opacity-60" />
          {score.toFixed(2)}
        </span>
      </TooltipTrigger>
      <TooltipContent>
        <p>Similarity score: {score.toFixed(2)}</p>
      </TooltipContent>
    </Tooltip>
  </TooltipProvider>
);

export const NoteItem: React.FC<{
  note: SimilarNote;
  openNote: (note: SimilarNote) => void;
}> = ({ note, openNote }) => {
  return (
    <div
      className="cursor-pointer hover:bg-accent/10 p-3 rounded transition-colors duration-200 w-full"
      onClick={() => openNote(note)}
    >
      <div className="flex justify-between items-center mb-2">
        <h3 className="font-semibold truncate mr-2">{note.title}</h3>
        <ScoreTooltip score={note.score} />
      </div>
      <div className="text-sm text-muted-foreground">
        {truncateContent(stripHtmlTags(note.content), 100)}
      </div>
    </div>
  );
};

--- src/renderer/features/notes/components/RightSidebar/RightSidebar.tsx ---

import React from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/renderer/shared/components/Tabs";
import RelatedNotes from "./RelatedNotes";
import ChatPane from "./ChatPane";
import ChatLocalPane from "./ChatLocalPane";

interface RightSidebarProps {
  isOpen: boolean;
  onClose: () => void;
}

const RightSidebar: React.FC<RightSidebarProps> = ({ isOpen, onClose }) => {
  return (
    <div className="h-full flex flex-col bg-background border-l border-border">
      <Tabs defaultValue="related" className="flex flex-col h-full">
        <div className="flex justify-between items-center p-2 h-10 border-b border-border">
          <TabsList className="flex gap-4 bg-transparent">
            <TabsTrigger 
              value="related" 
              className="font-semibold text-sm px-0 data-[state=active]:bg-transparent data-[state=active]:text-foreground"
            >
              Related
            </TabsTrigger>
            <TabsTrigger 
              value="chat" 
              className="font-semibold text-sm px-0 data-[state=active]:bg-transparent data-[state=active]:text-foreground"
            >
              Chat
            </TabsTrigger>
            <TabsTrigger 
              value="chat-local" 
              className="font-semibold text-sm px-0 data-[state=active]:bg-transparent data-[state=active]:text-foreground"
            >
              Chat Local
            </TabsTrigger>
          </TabsList>
        </div>
        <TabsContent value="related" className="flex-grow overflow-hidden p-0">
          <RelatedNotes isOpen={isOpen} onClose={onClose} />
        </TabsContent>
        <TabsContent value="chat" className="flex-grow overflow-hidden p-0">
          <ChatPane onClose={onClose} />
        </TabsContent>
        <TabsContent value="chat-local" className="flex-grow overflow-hidden p-0">
          <ChatLocalPane />
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default RightSidebar;

--- src/renderer/features/notes/components/RightSidebar/ChatLocalPane.tsx ---

import { ScrollArea } from "@radix-ui/react-scroll-area";
import { Input } from "@/renderer/shared/components/Input";
import { useCallback, useState } from "react";
import log from 'electron-log';

const API_URL = "http://localhost:11434/api/chat";

const createPayload = (question: string) => {
  return JSON.stringify({
    model: "llama3",
    messages: [{ role: "user", content: question }],
  });
};

export default function ChatLocalPane() {
  const [input, setInput] = useState<string>("");
  const [messages, setMessage] = useState<string>("");

  const handleSend = useCallback(async () => {
    log.info('Sending message to API');

    const response: Response = await fetch(API_URL, {
      method: "POST",
      body: createPayload(input),
    });
    const reader = response.body.getReader();
    const decoder = new TextDecoder("utf-8");
    let chunk = await reader.read();
    while (!chunk.done) {
      const chunkStr = decoder.decode(chunk.value);
      const lines = chunkStr.split("\n");
      for (const line of lines){
        if (line.length <= 0){
          continue;
        }
        try {
          const lineJson = JSON.parse(line.trim());
          const message = lineJson.message.content;
          setMessage(prev => prev+message);
          if (lineJson.done){
            log.info('Received complete response from API');
            break;
          }
        } catch (e){
          log.error('Error parsing chunk', e);
        }
      }
      chunk = await reader.read();
    }
  }, [input]);

  return (
    <div className="flex flex-col h-full">
      <ScrollArea className="flex flex-grow px-4">
        <div className="py-4 space-y-4">Messages: {messages}</div>
      </ScrollArea>
      <div className="border-t border-border p-4">
        <div className="flex items-center gap-2">
          <Input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                handleSend();
              }
            }}
            placeholder="Type your message..."
            className="flex-grow"
          />
        </div>
      </div>
    </div>
  );
}

--- src/renderer/features/notes/components/RightSidebar/RelatedNotes.tsx ---

import React, { useCallback, useEffect, useState } from "react";
import { Button } from "@/renderer/shared/components/Button";
import { ScrollArea } from "@/renderer/shared/components/ScrollArea";
import { Loader2, RefreshCw, Target } from "lucide-react";
import { toast } from "@/renderer/shared/components/Toast";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/renderer/shared/components/Tooltip";
import { SimilarNote } from "@/renderer/shared/types";
import { useNotesContext } from "../context/notesContext";
import { NoteItem } from "./RightSidebar/RelatedNoteListItem";

interface RelatedNotesProps {
  isOpen: boolean;
  onClose: () => void;
}

const RelatedNotes: React.FC<RelatedNotesProps> = ({ isOpen, onClose }) => {
  const [similarNotes, setSimilarNotes] = useState<SimilarNote[]>([]);
  const [similarNotesIsLoading, setSimilarNotesIsLoading] =
    useState<boolean>(false);

  const { activeNote, openNote, directoryStructures } = useNotesContext();

  const findSimilarNotes = useCallback(async () => {
    if (!activeNote) {
      console.error("No active note");
      setSimilarNotes([]);
      setSimilarNotesIsLoading(false);
      return;
    }
    setSimilarNotesIsLoading(true);
    try {
      const similarNotes = await window.electron.findSimilarNotes(
        activeNote.content,
        directoryStructures
      );
      setSimilarNotes(
        similarNotes.filter(
          (note: SimilarNote) => note.id !== activeNote.id && note.score >= 0.5
        )
      );
    } catch (error) {
      console.error("Error finding similar notes:", error);
      toast("Failed to find similar notes", {
        description: "An error occurred while searching for similar notes.",
      });
      setSimilarNotes([]);
    } finally {
      setSimilarNotesIsLoading(false);
    }
  }, [activeNote?.id]);

  useEffect(() => {
    if (isOpen && activeNote) {
      findSimilarNotes();
    }
  }, [isOpen, activeNote?.id, findSimilarNotes]);

  return (
    <div className="h-full flex flex-col">
      <ScrollArea className="flex-grow px-4">
        <div className="py-4">
          {similarNotesIsLoading ? (
            <div className="flex items-center justify-center h-20">
              <Loader2 className="h-6 w-6 animate-spin" />
            </div>
          ) : similarNotes.length > 0 ? (
            <div className="space-y-4">
              {similarNotes.map((note) => (
                <NoteItem key={note.id} note={note} openNote={openNote} />
              ))}
            </div>
          ) : (
            <p className="text-center text-muted-foreground py-8">
              No similar notes found
            </p>
          )}
        </div>
      </ScrollArea>
    </div>
  );
};

export default RelatedNotes;

--- src/renderer/features/notes/components/Notes.tsx ---

import React, { useState, useRef, useEffect } from "react";
import {
  Panel,
  PanelGroup,
  PanelResizeHandle,
  ImperativePanelHandle,
} from "react-resizable-panels";
import NoteEditor from "./NoteEditor/NoteEditor";
import NoteExplorer from "./NoteEditor/NoteExplorer";
import RightSidebar from "./RightSidebar/RightSidebar";
import { useNotesContext } from "../context/notesContext";

const Notes: React.FC<{
  isLeftSidebarOpen: boolean;
  isRightSidebarOpen: boolean;
  setIsLeftSidebarOpen: (isOpen: boolean) => void;
  setIsRightSidebarOpen: (isOpen: boolean) => void;
}> = ({
  isLeftSidebarOpen,
  isRightSidebarOpen,
  setIsLeftSidebarOpen,
  setIsRightSidebarOpen,
}) => {
  const { activeNote } = useNotesContext();
  const [leftSidebarSize, setLeftSidebarSize] = useState(18);
  const [rightSidebarSize, setRightSidebarSize] = useState(25); // Increased default size for better readability

  const leftPanelRef = useRef<ImperativePanelHandle>(null);
  const rightPanelRef = useRef<ImperativePanelHandle>(null);

  const handlePanelCollapse = (panelName: string) => {
    switch (panelName) {
      case "leftSidebar":
        setIsLeftSidebarOpen(false);
        break;
      case "rightSidebar":
        setIsRightSidebarOpen(false);
        break;
    }
  };

  useEffect(() => {
    if (leftPanelRef.current) {
      if (isLeftSidebarOpen) {
        leftPanelRef.current.expand();
      } else {
        leftPanelRef.current.collapse();
      }
    }
  }, [isLeftSidebarOpen]);

  useEffect(() => {
    if (rightPanelRef.current) {
      if (isRightSidebarOpen) {
        rightPanelRef.current.expand();
      } else {
        rightPanelRef.current.collapse();
      }
    }
  }, [isRightSidebarOpen]);

  const handleResize = (panelName: string) => (size: number) => {
    switch (panelName) {
      case "leftSidebar":
        setLeftSidebarSize(size);
        break;
      case "rightSidebar":
        setRightSidebarSize(size);
        break;
    }
  };

  return (
    <PanelGroup direction="horizontal" className="h-screen w-screen">
      <Panel
        ref={leftPanelRef}
        defaultSize={leftSidebarSize}
        minSize={10}
        maxSize={40}
        onResize={handleResize("leftSidebar")}
        collapsible={true}
        onCollapse={() => handlePanelCollapse("leftSidebar")}
      >
        <NoteExplorer
          isOpen={isLeftSidebarOpen}
          onClose={() => setIsLeftSidebarOpen(false)}
        />
      </Panel>
      <PanelResizeHandle className="w-1 bg-border hover:bg-accent/50 cursor-ew-resize" />
      <Panel>
        {activeNote ? (
          <NoteEditor note={activeNote} />
        ) : (
          <div className="flex w-full h-full justify-center items-center">
            Please select a note
          </div>
        )}
      </Panel>
      <PanelResizeHandle className="w-1 bg-border hover:bg-accent/50 cursor-ew-resize" />
      <Panel
        ref={rightPanelRef}
        defaultSize={rightSidebarSize}
        minSize={15}
        maxSize={45}
        onResize={handleResize("rightSidebar")}
        collapsible={true}
        onCollapse={() => handlePanelCollapse("rightSidebar")}
      >
        <RightSidebar
          isOpen={isRightSidebarOpen}
          onClose={() => setIsRightSidebarOpen(false)}
        />
      </Panel>
    </PanelGroup>
  );
};

export default Notes;

--- src/renderer/features/notes/hooks/useNoteExplorerContextMenu.tsx ---

// src/features/notes/hooks/useNoteExplorerContextMenu.tsx

import { FileNode } from "@/renderer/shared/types";
import { useState, useCallback, useEffect } from "react";

interface ContextMenuState {
  x: number;
  y: number;
  fileNode: FileNode;
}

export const useNoteExplorerContextMenu = () => {
  const [contextMenu, setContextMenu] = useState<ContextMenuState | null>(null);

  const handleContextMenu = useCallback(
    (
      e: React.MouseEvent,
      fileNode: FileNode
    ) => {
      e.preventDefault();
      e.stopPropagation();
      setContextMenu({
        x: e.clientX,
        y: e.clientY,
        fileNode
      });
    },
    []
  );

  const closeContextMenu = useCallback(() => {
    setContextMenu(null);
  }, []);

  useEffect(() => {
    const handleGlobalClick = () => {
      closeContextMenu();
    };

    if (contextMenu) {
      document.addEventListener("click", handleGlobalClick);
    }

    return () => {
      document.removeEventListener("click", handleGlobalClick);
    };
  }, [contextMenu, closeContextMenu]);

  return { contextMenu, handleContextMenu, closeContextMenu };
};

--- src/renderer/features/notes/hooks/useNotes.ts ---

// src/features/notes/hooks/useNotes.ts

import log from "electron-log";
import { v4 as uuidv4 } from "uuid";
import { useState, useEffect, useCallback, useMemo } from "react";
import {
  Note,
  FileNode,
  DirectoryStructures,
  SimilarNote,
  FileNodeMap,
} from "@/renderer/shared/types";
import { toast } from "@/renderer/shared/components/Toast";

export const useNotes = () => {
  const [notes, setNotes] = useState<Note[]>([]);
  const [directoryStructures, setDirectoryStructures] =
    useState<DirectoryStructures>({
      rootIds: [],
      nodes: {},
    });
  const [activeFileNodeId, setActiveFileNodeId] = useState<string | null>(null);
  const [activeNote, setActiveNote] = useState<Note | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // File System Explorer State
  const [expandedDirs, setExpandedDirs] = useState<Set<string>>(new Set());
  const [currentPath, setCurrentPath] = useState<string>("");
  const [isCreatingFolder, setIsCreatingFolder] = useState(false);
  const [newFolderName, setNewFolderName] = useState("");
  const [error, setError] = useState<string | null>(null);

  // Mounted Folder States
  const [mountedDirPaths, setMountedDirPaths] = useState<string[]>([]);
  const [isLoadingMountedDirPaths, setIsLoadingMountedDirPaths] =
    useState(false);
  const [mountedDirPathsLoadError, setMountedDirPathsLoadError] = useState<
    string | null
  >(null);

  useEffect(() => {
    if (activeFileNodeId) {
      const fileNode = directoryStructures.nodes[activeFileNodeId];
      if (fileNode) {
        setActiveFileNode(fileNode);
      } else {
        log.error("Could not find file node for id", activeFileNodeId);
      }
    }
  }, [activeFileNodeId, directoryStructures]);

  // Compute activeFileNode
  const activeFileNode = useMemo(() => {
    return activeFileNodeId
      ? directoryStructures.nodes[activeFileNodeId]
      : null;
  }, [activeFileNodeId, directoryStructures]);

  // Update functions to use activeFileNodeId
  const setActiveFileNode = useCallback((node: FileNode) => {
    setActiveFileNodeId(node.id);
  }, []);

  // Load the active note based on the active file node
  useEffect(() => {
    let isCurrent = true;

    const loadActiveNote = async () => {
      if (activeFileNode?.type === "note") {
        try {
          const loadedNote = await window.electron.loadNote(
            activeFileNode.fullPath
          );
          if (isCurrent) {
            setActiveNote(loadedNote);
          }
        } catch (err) {
          log.error("Failed to load note:", err);
          if (isCurrent) {
            setActiveNote(null);
          }
        }
      } else {
        if (isCurrent) {
          setActiveNote(null);
        }
      }
    };
    loadActiveNote();

    return () => {
      isCurrent = false;
    };
  }, [activeFileNode]);

  const loadNotes = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      log.info("Starting to load notes...");
      const topLevelDirPaths = await window.electron.getTopLevelFolders();
      log.info("Top level folders:", topLevelDirPaths);
      
      const dirStructuresPromises = topLevelDirPaths.map(async (dirPath) => {
        try {
          log.info(`Loading directory structure for: ${dirPath}`);
          const dirStructure = await window.electron.getDirectoryStructure(dirPath);
          log.info(`Successfully loaded structure for ${dirPath}:`, dirStructure);
          return dirStructure;
        } catch (err) {
          log.error(`Failed to load directory structure for ${dirPath}:`, err);
          setError(err);
          return null;
        }
      });

      const dirStructures = await Promise.all(dirStructuresPromises);
      log.info('All directory structures:', dirStructures);

      const newDirectoryStructures: DirectoryStructures = {
        rootIds: [],
        nodes: {},
      };

      dirStructures.forEach((dirStructure, index) => {
        if (dirStructure) {
          log.info(`Building structure for directory ${index}`);
          buildDirectoryStructures(dirStructure, null, newDirectoryStructures);
        }
      });

      log.info('Final directory structures:', newDirectoryStructures);
      setDirectoryStructures(newDirectoryStructures);
    } catch (err) {
      log.error("Failed to load notes:", err);
      setError(err);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const buildDirectoryStructures = (
    dirStructure: any,
    parentId: string | null,
    directoryStructures: DirectoryStructures
  ) => {
    const id = uuidv4();
    const fileNode: FileNode = {
      id,
      name: dirStructure.name,
      type: dirStructure.type,
      parentId,
      fullPath: dirStructure.fullPath,
      childIds: [],
    };
    if (dirStructure.type === "note" && dirStructure.noteMetadata) {
      fileNode.noteMetadata = dirStructure.noteMetadata;
    }
    directoryStructures.nodes[id] = fileNode;
    if (!parentId) {
      directoryStructures.rootIds.push(id);
    } else {
      const parent = directoryStructures.nodes[parentId];
      if (parent) {
        parent.childIds = parent.childIds || [];
        parent.childIds.push(id);
      }
    }
    if (dirStructure.children) {
      dirStructure.children.forEach((child: any) => {
        buildDirectoryStructures(child, id, directoryStructures);
      });
    }
  };

  useEffect(() => {
    loadNotes();
  }, [loadNotes]);

  const createNote = useCallback(
    async (dirPath: string) => {
      const timestamp = new Date().toISOString();
      const newNote: Note = {
        id: uuidv4(),
        title: "Untitled Note",
        content: "",
        createdAt: timestamp,
        updatedAt: timestamp,
      };
      try {
        const savedNotePath = await window.electron.saveNote(newNote, dirPath);

        log.info("saved new note path", savedNotePath);
        log.info("full path passed in =", dirPath);

        // Create a new FileNode for the note
        const newFileNodeId = uuidv4();
        const newFileNode: FileNode = {
          id: newFileNodeId,
          name: newNote.title,
          type: "note",
          parentId: null, // We'll update this later
          fullPath: savedNotePath,
          childIds: [],
          noteMetadata: {
            id: newNote.id,
            title: newNote.title,
            // Add other metadata as needed
          },
        };

        // Update the directory structure
        setDirectoryStructures((prevStructures) => {
          const updatedNodes: FileNodeMap = { ...prevStructures.nodes };
          const parentNode = Object.values(updatedNodes).find(
            (node) =>
              node.type === "directory" &&
              node.fullPath === savedNotePath.split("/").slice(0, -1).join("/")
          );

          log.info('parent node fullepath=', parentNode.fullPath)

          if (parentNode) {
            log.info('newFileNode.parentId', newFileNode.parentId)
            newFileNode.parentId = parentNode.id;
            updatedNodes[parentNode.id] = {
              ...parentNode,
              childIds: [...parentNode.childIds, newFileNodeId],
            };
          } else {
            // If no parent found, add to root
            prevStructures.rootIds.push(newFileNodeId);
          }

          updatedNodes[newFileNodeId] = newFileNode;

          return {
            ...prevStructures,
            nodes: updatedNodes,
          };
        });

        setActiveFileNodeId(newFileNodeId);
      } catch (error) {
        log.error("Error creating note:", error);
      }
    },
    [setDirectoryStructures, setActiveFileNodeId]
  );

  const saveNote = useCallback(
    async (updatedNote: Note) => {
      if (!activeFileNode || activeFileNode.type !== "note") {
        log.error("No active note file node");
        return;
      }
      try {
        const dirPath = activeFileNode.fullPath.substring(0, activeFileNode.fullPath.lastIndexOf("/"));
        await window.electron.saveNote(updatedNote, dirPath);

        // Correctly update the directoryStructures
        setDirectoryStructures((prevStructures) => {
          const updatedNodes = { ...prevStructures.nodes }; // Clone nodes object
          const nodeId = activeFileNode.id;
          const node = updatedNodes[nodeId];
          if (node) {
            updatedNodes[nodeId] = {
              ...node, // Create a new node object
              name: updatedNote.title,
              noteMetadata: {
                ...node.noteMetadata,
                title: updatedNote.title,
              },
            };
          }
          return {
            ...prevStructures,
            nodes: updatedNodes, // Use the updated nodes object
          };
        });

        // No need to update activeFileNode explicitly; it will update via useMemo
      } catch (error) {
        log.error("Error saving note:", error);
        toast.error("Failed to save note. Please try again.");
      }
    },
    [activeFileNode]
  );

  const deleteFileNode = useCallback(
    async (fileNode: FileNode) => {
      try {
        await window.electron.deleteFileNode(fileNode.type, fileNode.fullPath);

        // Update directory structures
        setDirectoryStructures((prevStructures) => {
          const updatedNodes = { ...prevStructures.nodes };
          const updatedRootIds = [...prevStructures.rootIds];

          // Remove the node
          delete updatedNodes[fileNode.id];

          // Remove from parent's childIds
          if (fileNode.parentId) {
            const parentNode = updatedNodes[fileNode.parentId];
            if (parentNode) {
              parentNode.childIds = parentNode.childIds.filter(
                (id) => id !== fileNode.id
              );
            }
          } else {
            // Remove from rootIds if it's a top-level node
            const rootIndex = updatedRootIds.indexOf(fileNode.id);
            if (rootIndex !== -1) {
              updatedRootIds.splice(rootIndex, 1);
            }
          }

          // Recursively remove all children
          const removeChildren = (nodeId: string) => {
            const node = updatedNodes[nodeId];
            if (node) {
              node.childIds.forEach(removeChildren);
              delete updatedNodes[nodeId];
            }
          };
          fileNode.childIds.forEach(removeChildren);

          return {
            rootIds: updatedRootIds,
            nodes: updatedNodes,
          };
        });

        // If it was a top-level folder, remove it from mountedDirPaths
        const topLevelFolderPaths = await window.electron.getTopLevelFolders();
        log.info("Top level folder paths:", topLevelFolderPaths);
        if (topLevelFolderPaths.includes(fileNode.fullPath)) {
          log.info(`Removing top-level folder: ${fileNode.fullPath}`);
          await window.electron.removeTopLevelFolder(fileNode.fullPath);
          setMountedDirPaths((prev) =>
            prev.filter((path) => path !== fileNode.fullPath)
          );
        }

        // Clear active node if it was deleted
        if (activeFileNodeId === fileNode.id) {
          setActiveFileNodeId(null);
          setActiveNote(null);
        }
      } catch (error) {
        log.error("Error deleting file node:", error);
        toast.error("Failed to delete file. Please try again.");
      }
    },
    [activeFileNodeId, setActiveFileNodeId, setActiveNote]
  );

  const toggleDirectory = useCallback((fileNode: FileNode) => {
    setExpandedDirs((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(fileNode.id)) {
        newSet.delete(fileNode.id);
      } else {
        newSet.add(fileNode.id);
      }
      return newSet;
    });
  }, []);

  const handleCreateFolder = useCallback((fileNode: FileNode) => {
    setActiveFileNode(fileNode);
    setIsCreatingFolder(true);
    setNewFolderName("");
    setError(null);
  }, []);

  const confirmCreateFolder = useCallback(async () => {
    if (!newFolderName.trim()) {
      setError("Folder name cannot be empty");
      return;
    }

    const invalidChars = /[<>:"/\\|?*\p{C}]/u;
    if (invalidChars.test(newFolderName)) {
      setError("Folder name contains invalid characters");
      return;
    }

    if (!activeFileNode) {
      setError("No active directory selected");
      return;
    }

    try {
      await window.electron.createDirectory(
        `${activeFileNode.fullPath}/${newFolderName.trim()}`
      );
      setIsCreatingFolder(false);
      setNewFolderName("");
      setError(null);
      await loadNotes();
    } catch (err) {
      setError(
        `Failed to create folder: ${
          err instanceof Error ? err.message : String(err)
        }`
      );
      log.error("Failed to create folder:", err);
    }
  }, [activeFileNode, newFolderName, loadNotes]);

  const cancelCreateFolder = useCallback(() => {
    setIsCreatingFolder(false);
    setNewFolderName("");
    setError(null);
  }, []);

  const loadMountedDirPaths = useCallback(async () => {
    setIsLoadingMountedDirPaths(true);
    setMountedDirPathsLoadError(null);

    try {
      const mountedDirPaths = await window.electron.getTopLevelFolders();
      setMountedDirPaths(mountedDirPaths);

      if (mountedDirPaths.length === 0) {
        log.info('No mounted directory paths found');
      }
    } catch (error) {
      log.error('Error loading mounted directory paths:', error);
      setMountedDirPathsLoadError('Failed to load mounted directory paths');
    } finally {
      setIsLoadingMountedDirPaths(false);
    }
  }, []);

  useEffect(() => {
    loadMountedDirPaths();
  }, [loadMountedDirPaths]);

  const openDialogToMountDirpath = useCallback(async () => {
    const result = await window.electron.openFolderDialog();
    if (result) {
      log.info(`Adding top-level folder: ${result}`);
      await window.electron.addTopLevelFolder(result);
      await loadMountedDirPaths();
      await loadNotes();
    }
  }, [loadMountedDirPaths, loadNotes]);

  const createEmbedding = useCallback(async (): Promise<boolean> => {
    if (activeFileNode?.type === "note" && activeNote) {
      try {
        await window.electron.generateNoteEmbeddings(
          activeNote,
          activeFileNode
        );
        return true;
      } catch (error) {
        log.error(`Failed generating note embedding:`, error);
        return false;
      }
    } else {
      log.error(`Embedding creation triggered for invalid file node type`);
      return false;
    }
  }, [activeFileNode, activeNote]);

  const getFileNodeFromNote = useCallback(
    (note: Note): FileNode | null => {
      const fileNode = Object.values(directoryStructures.nodes).find(
        (node) => node.type === "note" && node.noteMetadata?.id === note.id
      );
      return fileNode || null;
    },
    [directoryStructures]
  );

  const getFileNodeFromPath = useCallback(
    (fullPath: string): FileNode | null => {
      const fileNode = Object.values(directoryStructures.nodes).find(
        (node) => node.fullPath === fullPath
      );
      return fileNode || null;
    },
    [directoryStructures]
  );

  const findFileNodeIdByFullPath = useCallback(
    (fullPath: string): string | null => {
      const fileNode = Object.values(directoryStructures.nodes).find(
        (node) => node.fullPath === fullPath
      );
      return fileNode ? fileNode.id : null;
    },
    [directoryStructures]
  );

  const openNote = useCallback(
    (note: Note) => {
      const fileNode = getFileNodeFromNote(note);
      if (fileNode) {
        setActiveFileNodeId(fileNode.id);
      } else {
        log.error("Could not find file node for note", note);
      }
    },
    [getFileNodeFromNote]
  );

  const openNoteById = useCallback(
    (noteId: string) => {
      const fileNode = Object.values(directoryStructures.nodes).find(
        (node) => node.type === "note" && node.noteMetadata?.id === noteId
      );
      if (fileNode) {
        setActiveFileNodeId(fileNode.id);
      } else {
        log.error("Could not find file node for note ID", noteId);
      }
    },
    [directoryStructures, setActiveFileNodeId]
  );

  const performRAGChat = useCallback(
    async (conversation: { role: string; content: string }[]) => {
      try {
        const assistantMessage = await window.electron.performRAGChat(
          conversation,
          directoryStructures
        );
        return assistantMessage;
      } catch (error) {
        log.error("Error performing RAG Chat:", error);
        throw error;
      }
    },
    [directoryStructures]
  );

  return {
    notes,
    directoryStructures,
    isLoading,
    createNote,
    saveNote,
    loadNotes,
    activeFileNodeId,
    setActiveFileNodeId,
    activeNote,
    activeFileNode,
    setActiveFileNode,
    deleteFileNode,
    expandedDirs,
    toggleDirectory,
    currentPath,
    setCurrentPath,
    handleCreateFolder,
    newFolderState: {
      isCreatingFolder,
      newFolderName,
      setNewFolderName,
      confirmCreateFolder,
      cancelCreateFolder,
      error,
    },
    openDialogToMountDirpath,
    createEmbedding,
    getFileNodeFromNote,
    getFileNodeFromPath,
    openNote,
    error,
    performRAGChat,
    openNoteById,
  };
};

--- src/renderer/features/theme/index.tsx ---

export { ThemeProvider } from './context/ThemeContext'
export { ThemeToggle } from './components/ThemeToggle'
export { useTheme } from './hooks/useTheme'
export type { Theme } from './config/themeConfig'
--- src/renderer/features/theme/context/ThemeContext.tsx ---

import React, { createContext, useContext, useEffect, useState } from 'react'
import { Theme } from '../config/themeConfig'
import { applyTheme, getInitialTheme } from '../utils/themeUtils'

type ThemeContextType = {
  theme: Theme
  setTheme: (theme: Theme) => void
}

export const ThemeContext = createContext<ThemeContextType | undefined>(undefined)

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>(getInitialTheme)

  useEffect(() => {
    applyTheme(theme)
  }, [theme])

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}
--- src/renderer/features/theme/config/themeConfig.ts ---

export const THEME_STORAGE_KEY = 'theme'
export const DEFAULT_THEME = 'light'
export const AVAILABLE_THEMES = ['light', 'dark'] as const

export type Theme = typeof AVAILABLE_THEMES[number]
--- src/renderer/features/theme/utils/themeUtils.ts ---

import { Theme, THEME_STORAGE_KEY, DEFAULT_THEME } from '../config/themeConfig'

export function applyTheme(theme: Theme) {
  const root = window.document.documentElement
  root.classList.remove('light', 'dark')
  root.classList.add(theme)
  localStorage.setItem(THEME_STORAGE_KEY, theme)
}

export function getInitialTheme(): Theme {
  if (typeof window !== 'undefined') {
    let theme = localStorage.getItem(THEME_STORAGE_KEY) as Theme;
    console.log('theme after local storage retrieval: ', theme)
    if (!theme) {
      console.log('failed to retrieve theme')
      theme = DEFAULT_THEME
    }
    console.log('retrieved theme: ', theme)
    return theme
  }
  return DEFAULT_THEME
}
--- src/renderer/features/theme/components/ThemeToggle.tsx ---

import { Moon, Sun } from "lucide-react"
import { Button } from "@/renderer/shared/components/Button"
import { useTheme } from "../hooks/useTheme"

export function ThemeToggle() {
  const { setTheme, theme } = useTheme()

  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
    >
      <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
      <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  )
}
--- src/renderer/features/theme/hooks/useTheme.ts ---

import { useContext } from 'react'
import { ThemeContext } from '../context/ThemeContext'

export function useTheme() {
  const context = useContext(ThemeContext)
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider')
  }
  return context
}
--- src/renderer/features/feed/index.tsx ---

import Feed from './Feed';

export {
  Feed
};
--- src/renderer/features/feed/Feed.tsx ---

import { Card } from "@/renderer/shared/components/Card";

const Feed = () => (
  <div className="container mx-auto p-4 mt-2">
    <h2 className="text-2xl font-bold mb-4">Welcome</h2>
    <Card className="p-6 mb-6">
      <h3 className="text-xl font-semibold mb-3">About</h3>
      <p className="mb-4">
        This tool is focused on providing great UX for information management.
      </p>
    </Card>

    <Card className="p-6 mb-6">
      <h3 className="text-xl font-semibold mb-3">
        Getting Started
      </h3>
      <p className="mb-4">
        To get started, please follow these steps:
      </p>
      <ol className="list-decimal list-inside">
        <li>Go to the Settings page (in the top right)</li>
        <li>Enter your OpenAI API key in the designated field</li>
      </ol>
      <p className="mt-4">
        Currently, the OpenAI API key is only used to calculate vector
        embeddings of content, which are then ONLY stored on your local file
        system and possible by OpenAI. No guarantees may be made about how
        OpenAI handles the data on their end.
      </p>
    </Card>

    <Card className="p-6">
      <h3 className="text-xl font-semibold mb-3">
        Feature Status
      </h3>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <h4 className="font-bold mb-2">
            Functional Features:
          </h4>
          <ul className="list-disc list-inside">
            <li>Create, edit, and delete notes</li>
            <li>Light and dark theme</li>
            <li>Auto-save functionality</li>
            <li>Sidebar for quick note navigation</li>
          </ul>
        </div>
        <div>
          <h4 className="font-bold mb-2">In Progress:</h4>
          <ul className="list-disc list-inside">
            <li>Markdown editing (partially implemented)</li>
            <li>Automatic embedding process</li>
            <li>Feed implementation</li>
            <li>File tab implementation</li>
            <li>Infinitely nestable data structures</li>
            <li>AI-first search and chat functionality</li>
            <li>Customizable background agents</li>
          </ul>
        </div>
      </div>
    </Card>
  </div>
);

export default Feed;
--- src/renderer/features/kbar/index.tsx ---

export { KBar } from "./components/KBar";
export { KBarActionsProvider } from "./context/KBarActionsProvider";
--- src/renderer/features/kbar/context/KBarActionsProvider.tsx ---

import { Command, commandRegistry } from "@/renderer/features/commands";
import { useRegisterActions, Action, KBarProvider } from "kbar";
import { useEffect, useState, useCallback } from "react";

interface KBarContentProps {
  actions: Action[];
  children: React.ReactNode;
}

export const KBarContent: React.FC<KBarContentProps> = ({
  actions,
  children,
}) => {
  useRegisterActions(actions, [actions]);

  return <>{children}</>;
};

const KBarActionsProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [actions, setActions] = useState<Action[]>([]);

  const updateActions = useCallback((commands: Command[]) => {
    const registryActions = commands.map((command: Command) => ({
      id: command.id,
      name: command.name,
      shortcut: command.shortcut,
      perform: command.perform,
    }));
    setActions(registryActions);
  }, []);

  useEffect(() => {
    const subscription = commandRegistry
      .getCommandsObservable()
      .subscribe(updateActions);

    return () => {
      subscription.unsubscribe();
    };
  }, [updateActions]);

  return (
    <KBarProvider actions={actions} options={{ disableScrollbarManagement: true }}>
      <KBarContent actions={actions}>{children}</KBarContent>
    </KBarProvider>
  );
};

export { KBarActionsProvider };

--- src/renderer/features/kbar/components/KBar.tsx ---

import {
  KBarAnimator,
  KBarPortal,
  KBarPositioner,
  KBarSearch,
  KBarResults,
  useMatches,
  ActionImpl,
} from "kbar";

const KBar = () => {
  return (
    <KBarPortal>
      <KBarPositioner className="fixed inset-0 z-50 flex items-start justify-center bg-black bg-opacity-50">
        <KBarAnimator className="max-w-xl w-full bg-white dark:bg-gray-800 shadow-lg rounded-lg overflow-hidden">
          <KBarSearch className="px-4 py-3 text-base w-full box-border outline-none border-none text-black dark:text-white bg-white dark:bg-gray-800" />
          <RenderResults />
        </KBarAnimator>
      </KBarPositioner>
    </KBarPortal>
  );
};

function RenderResults() {
  const { results } = useMatches();

  return (
    <KBarResults
      items={results}
      onRender={({ item, active }: { item: ActionImpl; active: boolean }) => (
        <div
          className={`px-4 py-2 cursor-pointer ${
            active
              ? "bg-blue-500 text-white"
              : "bg-white dark:bg-gray-800 text-black dark:text-white"
          }`}
        >
          {item.name}
        </div>
      )}
    />
  );
}

export { KBar };

--- src/renderer/features/commands/components/CommandPalette.tsx ---

import React from 'react';
import { useCommands } from '../hooks/useCommands';

export const CommandPalette: React.FC = () => {
  const { getAllCommands, executeCommand } = useCommands();
  const commands = getAllCommands();

  return (
    <div>
      {commands.map(command => (
        <button key={command.id} onClick={() => executeCommand(command.id)}>
          {command.name}
        </button>
      ))}
    </div>
  );
};
--- src/renderer/features/commands/hooks/useCommands.ts ---

import { useCallback } from 'react';
import { Command, commandRegistry } from '../services/commandRegistry';

export const useCommands = () => {
  const registerCommand = useCallback((command: Command) => {
    commandRegistry.registerCommand(command);
  }, []);

  const executeCommand = useCallback((id: string) => {
    commandRegistry.executeCommand(id);
  }, []);

  const getAllCommands = useCallback(() => {
    return commandRegistry.getAllCommands();
  }, []);

  const unregisterCommand = useCallback((command: Command) => {
    commandRegistry.unregisterCommand(command);
  }, []);

  return { registerCommand, executeCommand, getAllCommands, unregisterCommand };
};
--- src/renderer/features/commands/index.ts ---

export { commandRegistry } from './services/commandRegistry';
export { useCommands } from './hooks/useCommands';
export { CommandPalette } from './components/CommandPalette';
export type { Command, CommandType } from './services/commandRegistry';

--- src/renderer/features/commands/services/commandRegistry.ts ---



import { BehaviorSubject, Observable } from "rxjs";

export type CommandType = 'paneToggle' | 'navigation' | 'action';

export interface Command {
  id: string;
  name: string;
  type: CommandType;
  shortcut?: string[];
  keywords: string[];
  perform: () => void;
}

class CommandRegistry {
  private commands: Map<string, Command> = new Map();
  private commandsSubject: BehaviorSubject<Command[]> = new BehaviorSubject<Command[]>([]);

  private emitCommands(): void {
    this.commandsSubject.next(this.getAllCommands());
  }

  registerCommand(command: Command): void {
    if (this.commands.has(command.id)) {
      throw new Error(`Command with id ${command.id} already exists`);
    }
    this.commands.set(command.id, command);
    this.emitCommands();
  }

  unregisterCommand(command: Command): void {
    if (!this.commands.has(command.id)) {
      throw new Error(`Command with id ${command.id} does not exist`);
    }
    this.commands.delete(command.id);
    this.emitCommands();
  }

  getCommand(id: string): Command | undefined {
    if (!this.commands.has(id)) {
      throw new Error(`Command with id ${id} does not exist`);
    }
    return this.commands.get(id);
  }

  getAllCommands(): Command[] {
    return Array.from(this.commands.values());
  }

  executeCommand(id: string): void {
    const command = this.commands.get(id);
    if (!command) {
      throw new Error(`Command with id ${id} does not exist`);
    }
    command.perform();
  }

  getCommandsObservable(): Observable<Command[]> {
    return this.commandsSubject.asObservable();
  }
}

export const commandRegistry = new CommandRegistry();
--- src/renderer/index.css ---

@import 'katex/dist/katex.min.css';

@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 0%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 0%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 0%;
    --primary: 210 100% 50%;
    --primary-foreground: 0 0% 100%;
    --secondary: 210 20% 96%;
    --secondary-foreground: 0 0% 0%;
    --muted: 210 20% 96%;
    --muted-foreground: 215 16% 47%;
    --accent: 210 20% 96%;
    --accent-foreground: 0 0% 0%;
    --destructive: 0 84% 60%;
    --destructive-foreground: 0 0% 100%;
    --border: 220 13% 91%;
    --input: 220 13% 91%;
    --ring: 142 76% 36%;
    --radius: 0.5rem;
    --gradient-start: 142 76% 33%;
    --gradient-end: 142 76% 39%;
  }
 
  .dark {
    --background: 220 6% 10%;
    --foreground: 210 6% 93%;
    --card: 220 6% 13%;
    --card-foreground: 210 6% 93%;
    --popover: 220 6% 13%;
    --popover-foreground: 210 6% 93%;
    --primary: 220 70% 40%;
    --primary-foreground: 0 0% 100%;
    --secondary: 220 6% 16%;
    --secondary-foreground: 210 6% 93%;
    --muted: 220 6% 20%;
    --muted-foreground: 217 8% 64%;
    --accent: 220 6% 20%;
    --accent-foreground: 210 6% 93%;
    --destructive: 0 84% 60%;
    --destructive-foreground: 0 0% 100%;
    --border: 220 6% 18%;
    --input: 220 6% 18%;
    --ring: 142 76% 45%;
    --gradient-start: 142 76% 42%;
    --gradient-end: 142 76% 48%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@layer utilities {
  .bg-gradient-primary {
    background: linear-gradient(135deg, hsl(var(--gradient-start)), hsl(var(--gradient-end)));
  }
}

/* For making the navbar draggable */
.drag-handle {
  -webkit-app-region: drag;
}

.drag-handle button,
.drag-handle a {
  -webkit-app-region: no-drag;
}
--- src/renderer/shared/types/index.ts ---

// src/shared/types/index.ts

import OpenAI from "openai";

export interface NoteMetadata {
  id: string;
  title: string;
  createdAt?: string;
  updatedAt?: string;
  tags?: string[];
}

export interface NoteContent {
  content?: string;
}

export interface Note extends NoteMetadata, NoteContent {}

export interface FileNode {
  id: string;
  name: string;
  type: 'directory' | 'note';
  parentId: string | null;
  noteMetadata?: NoteMetadata;
  fullPath: string;
  childIds?: string[];
}

export interface FileNodeMap {
  [id: string]: FileNode;
}

export interface DirectoryStructures {
  rootIds: string[];
  nodes: FileNodeMap;
}

export interface SimilarNote extends Note {
  score: number;
}

export interface TabInfo {
  id: string;
  title: string;
}

export type Embedding = OpenAI.Embeddings.CreateEmbeddingResponse;

export interface Config {
  openaiApiKey?: string;
}

export interface DirectoryEntry {
  name: string;
  type: "directory" | "note";
  noteMetadata?: NoteMetadata;
  fullPath: string;
  children?: DirectoryEntry[];
}
--- src/renderer/shared/utils/cn.ts ---

/**
 * Utility function to conditionally join classNames together
 * @param {...string} classes - List of class names
 * @returns {string} Joined class names string
 */
export function cn(...classes: string[]): string {
  return classes.filter(Boolean).join(' ');
}

--- src/renderer/shared/utils/fileUtils.ts ---

import fs from 'fs';

export function createDirectoryIfNotExists(dirPath: string){
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

--- src/renderer/shared/utils/index.ts ---

export * from './fileUtils';
export * from './cn';
--- src/renderer/shared/components/Tabs/index.tsx ---

export { default as Tabs } from './Tabs';
export { default as TabsList } from './TabsList';
export { default as TabsTrigger } from './TabsTrigger';
export { default as TabsContent } from './TabsContent';
export { default as CustomTabBar } from './CustomTabBar';
--- src/renderer/shared/components/Tabs/Tabs.tsx ---

import * as TabsPrimitive from "@radix-ui/react-tabs";

const Tabs = TabsPrimitive.Root;

export default Tabs;
--- src/renderer/shared/components/Tabs/TabsContent.tsx ---

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/renderer/shared/utils";

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background",
      "focus-visible:outline-none focus-visible:ring-2",
      "focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
));
TabsContent.displayName = "TabsContent";

export default TabsContent;
--- src/renderer/shared/components/Tabs/TabsTrigger.tsx ---

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/renderer/shared/utils";

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap",
      "rounded-sm px-3 py-1.5 text-sm font-medium",
      "ring-offset-background transition-all",
      "focus-visible:outline-none focus-visible:ring-2",
      "focus-visible:ring-ring focus-visible:ring-offset-2",
      "disabled:pointer-events-none disabled:opacity-50",
      "data-[state=active]:bg-background data-[state=active]:text-foreground",
      "data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
));
TabsTrigger.displayName = "TabsTrigger";

export default TabsTrigger;
--- src/renderer/shared/components/Tabs/TabsList.tsx ---

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/renderer/shared/utils";

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md",
      "bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
));
TabsList.displayName = "TabsList";

export default TabsList;
--- src/renderer/shared/components/Tabs/CustomTabBar.tsx ---

import React from 'react';
import { X } from 'lucide-react';
import { Button } from '@/renderer/shared/components/Button';
import { cn } from '@/renderer/shared/utils';

interface Tab {
  id: string;
  title: string;
}

interface CustomTabBarProps {
  tabs: Tab[];
  activeTab: string;
  onTabClick: (id: string) => void;
  onTabClose: (id: string) => void;
  onTabDragStart: (id: string, e: React.DragEvent) => void;
}

const CustomTabBar: React.FC<CustomTabBarProps> = ({
  tabs,
  activeTab,
  onTabClick,
  onTabClose,
  onTabDragStart,
}) => {
  return (
    <div className="flex bg-background border-b border-border overflow-x-auto mt-2">
      {tabs.map((tab) => (
        <div
          key={tab.id}
          className={cn(
            "flex items-center px-3 py-2 border-r border-border cursor-pointer group",
            activeTab === tab.id
              ? "bg-accent text-accent-foreground"
              : "hover:bg-accent/50"
          )}
          onClick={() => onTabClick(tab.id)}
          draggable
          onDragStart={(e) => onTabDragStart(tab.id, e)}
        >
          <span className="mr-2 truncate max-w-[120px]">{tab.title}</span>
          <Button
            variant="ghost"
            size="icon"
            className="h-4 w-4 ml-2 opacity-0 group-hover:opacity-100 transition-opacity"
            onClick={(e) => {
              e.stopPropagation();
              onTabClose(tab.id);
            }}
          >
            <X className="h-3 w-3" />
          </Button>
        </div>
      ))}
    </div>
  );
};

export default CustomTabBar;
--- src/renderer/shared/components/Card.tsx ---

import React from "react";

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: "default" | "primary";
}

export const Card: React.FC<CardProps> = ({
  children,
  className,
  variant = "default",
  ...props
}) => {
  const baseClasses = "rounded-2xl p-4 transition-shadow duration-200";
  const variantClasses =
    variant === "primary"
      ? "bg-gradient-primary text-primary-foreground"
      : "bg-secondary text-secondary-foreground";

  return (
    <div
      className={`${baseClasses} ${variantClasses} hover:shadow-md ${
        className || ""
      }`}
      {...props}
    >
      {children}
    </div>
  );
};

--- src/renderer/shared/components/ContextMenu/ContextMenu.tsx ---

import React from 'react';
import { cn } from '@/renderer/shared/utils';

interface ContextMenuProps {
  x: number;
  y: number;
  onClose: () => void;
  children: React.ReactNode;
}

const ContextMenu: React.FC<ContextMenuProps> = ({ x, y, onClose, children }) => {
  return (
    <div
      className={cn(
        "absolute z-50 min-w-[200px] bg-popover text-popover-foreground",
        "rounded-md shadow-md overflow-hidden"
      )}
      style={{ top: y, left: x }}
    >
      {children}
    </div>
  );
};

export default ContextMenu;
--- src/renderer/shared/components/ContextMenu/ContextMenuItem.tsx ---

import React from 'react';
import { Button } from '@/renderer/shared/components/Button';
import { LucideIcon } from 'lucide-react';

interface ContextMenuItemProps {
  icon?: LucideIcon;
  label: string;
  onClick: () => void;
  className?: string;
}

const ContextMenuItem: React.FC<ContextMenuItemProps> = ({ icon: Icon, label, onClick, className }) => {
  return (
    <Button
      variant="ghost"
      className={`w-full justify-start px-2 py-1.5 text-sm ${className}`}
      onClick={onClick}
    >
      {Icon && <Icon className="mr-2 h-4 w-4" />}
      {label}
    </Button>
  );
};

export default ContextMenuItem;
--- src/renderer/shared/components/Tooltip.tsx ---

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { cn } from "@/renderer/shared/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      `z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5
       text-sm text-popover-foreground shadow-md animate-in fade-in-0
       zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0
       data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2
       data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2
       data-[side=top]:slide-in-from-bottom-2
      `,
      className
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

--- src/renderer/shared/components/ScrollArea.tsx ---

import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";
import { cn } from "@/renderer/shared/utils";

// ScrollArea: A customizable scrollable area component
const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root> & {
    hideScrollbar?: boolean;
  }
>(({ className, children, hideScrollbar = false, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    {!hideScrollbar && <ScrollBar />}
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = "ScrollArea";

// ScrollBar: A customizable scrollbar component
const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = "ScrollBar";

export { ScrollArea, ScrollBar };

--- src/renderer/shared/components/DropdownMenu.tsx ---

import * as React from 'react'
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu'
import { Check, ChevronRight, Circle } from 'lucide-react'

import { cn } from '@/renderer/shared/utils/index'

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      'px-2 py-1.5 text-sm font-semibold',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn('ml-auto text-xs tracking-widest opacity-60', className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = 'DropdownMenuShortcut'

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
--- src/renderer/shared/components/Button.tsx ---

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/renderer/shared/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  (
    { className, variant, size, asChild = false, ...props },
    ref
  ): JSX.Element => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = "Button";

export { Button, buttonVariants };

--- src/renderer/shared/components/Toggle.tsx ---

import * as React from "react";
import * as TogglePrimitive from "@radix-ui/react-toggle";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/renderer/shared/utils";

const toggleVariants = cva(
  `inline-flex items-center justify-center rounded-md text-sm font-medium
  ring-offset-background transition-colors hover:bg-muted
  hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2
  focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none
  disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground`,
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: `border border-input bg-transparent hover:bg-accent
                  hover:text-accent-foreground`,
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };

--- src/renderer/shared/components/Toast.tsx ---

import { Toaster as SonnerToaster, toast as sonnerToast } from 'sonner';

export const Toaster = SonnerToaster;

export const toast = sonnerToast;
--- src/renderer/shared/components/input.tsx ---

import * as React from "react";
import { cn } from "@/renderer/shared/utils";
import { InputHTMLAttributes } from "react";

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  variant?: 'default' | 'minimal';
}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, variant = 'default', ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          // Default styles
          `flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm
          ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium
          placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-0
          disabled:cursor-not-allowed disabled:opacity-50`,
          // Minimal variant styles
          variant === 'minimal' && `h-auto w-auto border-none bg-transparent p-0`,
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = "Input";

export { Input };
--- src/renderer/shared/hooks/useResizablePane.ts ---

import { useCallback, useRef, useEffect } from 'react';

interface UseResizablePaneProps {
  minHeight?: number;
  maxHeight?: number;
  minWidth?: number;
  maxWidth?: number;
  height?: number;
  setHeight?: (height: number) => void;
  width?: number;
  setWidth?: (width: number) => void;
  paneRef: React.RefObject<HTMLDivElement>;
  direction: 'horizontal' | 'vertical';
}

export const useResizablePane = ({
  minHeight,
  maxHeight,
  minWidth,
  maxWidth,
  height,
  setHeight,
  width,
  setWidth,
  paneRef,
  direction,
}: UseResizablePaneProps) => {
  const isResizing = useRef(false);

  const startResizing = useCallback((e: React.MouseEvent) => {
    isResizing.current = true;
    document.addEventListener('mousemove', resize);
    document.addEventListener('mouseup', stopResizing);
  }, []);

  const resize = useCallback((e: MouseEvent) => {
    if (!isResizing.current || !paneRef.current) return;
    if (direction === 'vertical') {
      const newHeight = window.innerHeight - e.clientY;

      if (newHeight >= (minHeight || 0) && newHeight <= (maxHeight || Infinity)) {
        if (setHeight) setHeight(newHeight);
      }
    } else if (direction === 'horizontal') {
      // Handle horizontal resizing if needed
    }
  }, [minHeight, maxHeight, setHeight, paneRef, direction]);

  const stopResizing = useCallback(() => {
    isResizing.current = false;
    document.removeEventListener('mousemove', resize);
    document.removeEventListener('mouseup', stopResizing);
  }, [resize]);

  useEffect(() => {
    return () => {
      document.removeEventListener('mousemove', resize);
      document.removeEventListener('mouseup', stopResizing);
    };
  }, [resize, stopResizing]);

  return { startResizing };
};

--- src/renderer/shared/hooks/useLocalStorage.ts ---

import { useState, useEffect } from "react";

function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T) => void] {
  // Get from local storage then
  // parse stored json or return initialValue
  const readValue = () => {
    if (typeof window === "undefined") {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  };

  const [storedValue, setStoredValue] = useState<T>(readValue);

  const setValue = (value: T) => {
    try {
      const newValue = value instanceof Function ? value(storedValue) : value;
      window.localStorage.setItem(key, JSON.stringify(newValue));
      setStoredValue(newValue);
    } catch (error) {
      console.warn(`Error setting localStorage key "${key}":`, error);
    }
  };

  useEffect(() => {
    setStoredValue(readValue());
  }, []);

  return [storedValue, setValue];
}

export default useLocalStorage;

--- src/renderer/shared/hooks/useDebounce.ts ---

import { useState, useEffect } from 'react';

/**
 * A hook that debounces a value.
 * 
 * @param value The value to be debounced
 * @param delay The delay in milliseconds
 * @returns The debounced value
 */
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Set up a timer to update the debounced value after the specified delay
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Clean up the timer if the value changes before the delay has passed
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}
--- src/renderer/shared/hooks/useResizableSidebar.ts ---

import { useState, useCallback, useRef, useEffect } from 'react';

interface UseResizableSidebarProps {
  minWidth: number;
  maxWidth: number;
  defaultWidth: number;
  isOpen: boolean;
  onResize: (width: number) => void;
  onClose: () => void;
  side: 'left' | 'right';
}

export const useResizableSidebar = ({
  minWidth,
  maxWidth,
  defaultWidth,
  isOpen,
  onResize,
  onClose,
  side,
}: UseResizableSidebarProps) => {
  const [width, setWidth] = useState(defaultWidth);
  const sidebarRef = useRef<HTMLDivElement>(null);
  const isResizing = useRef(false);

  const startResizing = useCallback((e: React.MouseEvent) => {
    isResizing.current = true;
    document.addEventListener('mousemove', resize);
    document.addEventListener('mouseup', stopResizing);
  }, []);

  const resize = useCallback((e: MouseEvent) => {
    if (!isResizing.current) return;
    
    let newWidth;
    if (side === 'left') {
      newWidth = e.clientX;
    } else {
      newWidth = window.innerWidth - e.clientX;
    }

    if (newWidth >= minWidth && newWidth <= maxWidth) {
      setWidth(newWidth);
      onResize(newWidth);
    }
  }, [minWidth, maxWidth, onResize, side]);

  const stopResizing = useCallback(() => {
    isResizing.current = false;
    document.removeEventListener('mousemove', resize);
    document.removeEventListener('mouseup', stopResizing);
  }, [resize]);

  useEffect(() => {
    return () => {
      document.removeEventListener('mousemove', resize);
      document.removeEventListener('mouseup', stopResizing);
    };
  }, [resize, stopResizing]);

  return { width, sidebarRef, startResizing };
};
--- src/renderer/styles/NoteEditor.css ---

.ProseMirror {
  /* Base editor spacing */
  font-size: 15px;
  margin: 0;
  line-height: 1.50;
  font-family: 'Arial', sans-serif;
  color: 'white';

  /* Regular paragraphs */
  p {
    margin: 0em;
  }

  /* Headings */
  h1, h2 {
    margin-top: 1em;
    margin-bottom: .3em;
    font-weight: 400;
    line-height: 1.3;
  }
  h3, h4, h5, h6 {
    margin-top: .3em;
    margin-bottom: .3em;
    font-weight: 400;
    line-height: 1.3;
  }

  h1 {
    font-size: 2em;
  }

  h2 {
    font-size: 1.5em;
  }

  h3 {
    font-size: 1.17em;
  }

  /* Lists */
  ul, ol {
    margin: 0;
    padding-left: 2em;
  }

  li {
    /* margin-bottom: 5px; */
    margin: 0;
  }

  /* Nested lists should have less margin */
  li > ul, li > ol {
    /* margin: 5px 0; */
    margin: 0;
  }

  /* Code blocks */
  pre {
    margin: 15px 0;
    padding: 16px;
    border-radius: 3px;
    background-color: 'black';
    overflow-x: auto;
  }

  code {
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.9em;
    line-height: 1.2em;
  }

  /* Blockquotes */
  blockquote {
    margin: 15px 0;
    padding-left: 1em;
    border-left: 4px solid #ccc;
    color: #666;
  }

  /* Tables */
  table {
    margin: 15px 0;
    border-collapse: collapse;
    border: 1px solid #ddd;
  }

  td, th {
    border: 1px solid #ddd;
    padding: 8px;
  }

  /* Horizontal rule */
  hr {
    margin: 15px 0;
    border: none;
    border-top: 1px solid #ddd;
  }
}
--- src/renderer/styles/GlobalStyles.ts ---

import { createGlobalStyle } from 'styled-components';

const GlobalStyles = createGlobalStyle`
  body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  }

  #root {
    height: 100vh;
    width: 100vw;
    overflow: hidden;
  }
`;

export default GlobalStyles;
--- src/renderer/styles/common/components.ts ---

import styled from 'styled-components';

export const Button = styled.button`
  background-color: ${({ theme }) => theme.primary};
  color: ${({ theme }) => theme.buttonText};
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s ease;

  &:hover {
    background-color: ${({ theme }) => theme.primaryHover};
  }

  svg {
    margin-right: 0.5rem;
  }
`;

export const Input = styled.input`
  font-size: 16px;
  padding: 0.5rem;
  border: 1px solid ${({ theme }) => theme.border};
  border-radius: 8px;
  background-color: ${({ theme }) => theme.inputBackground};
  color: ${({ theme }) => theme.text};
  transition: border-color 0.3s ease;

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.primary};
  }
`;

export const Card = styled.div`
  background-color: ${({ theme }) => theme.cardBackground};
  border-radius: 12px;
  padding: 1rem;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
`;
--- src/main.ts ---

import { app, BrowserWindow, ipcMain, dialog } from "electron";
import path from "path";
import { setupFileSystem } from "./main/fileSystem";
import {
  addTopLevelFolder,
  getTopLevelFolders,
  removeTopLevelFolder,
} from "./main/configManager";
import { setupEmbeddingService } from "./main/embeddings";
import log from "./main/logger";
import { DEFAULT_WINDOW_HEIGHT, DEFAULT_WINDOW_WIDTH } from "./renderer/config/setup";


// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

let mainWindow: BrowserWindow | null = null;
const isDevelopment = process.env.NODE_ENV === "development";

// More lenient CSP
const CSP = [
  "default-src 'self'",
  "script-src 'self' 'unsafe-inline' 'unsafe-eval'",
  "style-src 'self' 'unsafe-inline'",
  "img-src 'self' data: https:",
  "font-src 'self' data:",
  // This is used for Ollama 
  "connect-src 'self' https: ws: http://localhost:11434",
  "media-src 'self' https:",
];

const createWindow = () => {
  log.info(`Creating main window; windowWidth: ${DEFAULT_WINDOW_WIDTH}, windowHeight: ${DEFAULT_WINDOW_HEIGHT}`);
  mainWindow = new BrowserWindow({
    width: DEFAULT_WINDOW_WIDTH,
    height: DEFAULT_WINDOW_HEIGHT,
    frame: false,
    webPreferences: {
      preload: path.join(__dirname, "preload.js"),
      // Block the render process from having direct NodeJS access
      nodeIntegration: false,
      // Separate JS context for render process from the main process
      contextIsolation: true,
      // Restricts what the render process can do at a system level
      sandbox: true,
    },
  });

  // Set Content Security Policy
  mainWindow.webContents.session.webRequest.onHeadersReceived(
    (details, callback) => {
      callback({
        responseHeaders: {
          ...details.responseHeaders,
          "Content-Security-Policy": [CSP.join("; ")],
        },
      });
    }
  );

  // Load the main page (which will contain the navigation)
  if (MAIN_WINDOW_VITE_DEV_SERVER_URL) {
    log.info(`Loading URL: ${MAIN_WINDOW_VITE_DEV_SERVER_URL}`);
    mainWindow.loadURL(MAIN_WINDOW_VITE_DEV_SERVER_URL);
  } else {
    const filePath = path.join(__dirname, `../renderer/${MAIN_WINDOW_VITE_NAME}/index.html`);
    log.info(`Loading file: ${filePath}`);
    mainWindow.loadFile(filePath);
  }

  // Open the DevTools in development
  if (isDevelopment){
    mainWindow.webContents.openDevTools();
  }

  mainWindow.webContents.on('did-finish-load', () => {
    log.info('Main window finished loading');
  });

  mainWindow.webContents.on('did-fail-load', (_, errorCode, errorDescription) => {
    log.error(`Failed to load page: ${errorCode} - ${errorDescription}`);
  });
};

// Set up IPC listeners for window controls
ipcMain.on("minimize-window", () => {
  log.info('Minimizing window');
  mainWindow?.minimize();
});

ipcMain.on("maximize-window", () => {
  if (mainWindow?.isMaximized()) {
    log.info('Unmaximizing window');
    mainWindow.unmaximize();
  } else {
    log.info('Maximizing window');
    mainWindow?.maximize();
  }
});

ipcMain.on("close-window", () => {
  log.info('Closing window');
  mainWindow?.close();
});

// This method will be called when Electron has finished initialization
app.whenReady().then(async () => {

  // Log permission errors
  process.on('uncaughtException', (error) => {
    console.log('error-1', error)
  });

  try {
    await setupFileSystem();
    log.info('File system setup complete');
    await setupEmbeddingService();
    log.info('Embedding service setup complete');
    createWindow();
  } catch (error) {
    log.error(`Error during app setup: ${error}`);
  }
});

// Quit when all windows are closed, except on macOS
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    log.info('All windows closed, quitting app');
    app.quit();
  }
});

app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    log.info('Activating app, creating new window');
    createWindow();
  }
});

// Add error handling
process.on("uncaughtException", (error) => {
  log.error(`Uncaught exception: ${error}`);
  dialog.showErrorBox('An error occurred', error.message);
});

// IPC handlers for top-level folder management
ipcMain.handle("get-top-level-folders", async () => {
  log.info('Getting top-level folders');
  return getTopLevelFolders();
});

ipcMain.handle("add-top-level-folder", async (_, folderPath) => {
  log.info(`Adding top-level folder: ${folderPath}`);
  await addTopLevelFolder(folderPath);
  return getTopLevelFolders();
});

ipcMain.handle("remove-top-level-folder", async (_, folderPath) => {
  log.info(`Removing top-level folder: ${folderPath}`);
  await removeTopLevelFolder(folderPath);
  return getTopLevelFolders();
});

// Folder selection dialog handler
ipcMain.handle("open-folder-dialog", async () => {
  log.info('Opening folder dialog');
  const result = await dialog.showOpenDialog({
    properties: ["openDirectory", "createDirectory"],
    buttonLabel: "Select Folder",
    title: "Select a folder to add as a top-level folder",
  });

  if (!result.canceled && result.filePaths.length > 0) {
    log.info(`Folder selected: ${result.filePaths[0]}`);
    return result.filePaths[0];
  }
  log.info('Folder selection cancelled');
  return null;
});
--- src/preload.ts ---

import { contextBridge, ipcRenderer } from "electron";
import { Note, FileNode, DirectoryStructures, Embedding, SimilarNote } from "./renderer/shared/types";

contextBridge.exposeInMainWorld("electron", {
  saveNote: (note: Note, dirPath: string) =>
    ipcRenderer.invoke("save-note", note, dirPath),
  deleteNote: (noteId: string, dirPath: string) =>
    ipcRenderer.invoke("delete-note", noteId, dirPath),
  minimize: () => ipcRenderer.send("minimize-window"),
  maximize: () => ipcRenderer.send("maximize-window"),
  close: () => ipcRenderer.send("close-window"),
  getNotePath: (noteId: string) => ipcRenderer.invoke("get-note-path", noteId),
  getOpenAIKey: () => ipcRenderer.invoke("get-openai-key"),
  setOpenAIKey: (key: string) => ipcRenderer.invoke("set-openai-key", key),
  createDirectory: (dirPath: string) =>
    ipcRenderer.invoke("create-directory", dirPath),
  deleteDirectory: (dirPath: string) =>
    ipcRenderer.invoke("delete-directory", dirPath),
  getTopLevelFolders: () => ipcRenderer.invoke("get-top-level-folders"),
  addTopLevelFolder: (folderPath: string) =>
    ipcRenderer.invoke("add-top-level-folder", folderPath),
  removeTopLevelFolder: (folderPath: string) =>
    ipcRenderer.invoke("remove-top-level-folder", folderPath),
  openFolderDialog: () => ipcRenderer.invoke("open-folder-dialog"),
  getDirectoryStructure: (dirPath: string) =>
    ipcRenderer.invoke("get-directory-structure", dirPath),
  loadNote: (notePath: string) => ipcRenderer.invoke("load-note", notePath),
  deleteFileNode: (fileNodeType: string, fileNodePath: string) =>
    ipcRenderer.invoke("delete-file-node", fileNodeType, fileNodePath),
  generateNoteEmbeddings: (note: Note, fileNode: FileNode) =>
    ipcRenderer.invoke("generate-note-embeddings", note, fileNode),
  findSimilarNotes: (query: string, directoryStructures: DirectoryStructures) =>
    ipcRenderer.invoke("perform-similarity-search", query, directoryStructures),
  performRAGChat: (
    conversation: { role: string; content: string }[],
    directoryStructures: DirectoryStructures
  ) => ipcRenderer.invoke("perform-rag-chat", conversation, directoryStructures),
});

--- src/main/configManager.ts ---

import { app } from 'electron';
import fs from 'fs/promises';
import path from 'path';
import log from 'electron-log';

interface Config {
  topLevelFolders: string[];
}

const CONFIG_FILE = path.join(app.getPath('userData'), 'config.json');
log.info(`Initialized CONFIG_FILE=${CONFIG_FILE}`);

async function readConfig(): Promise<Config> {
  try {
    const data = await fs.readFile(CONFIG_FILE, 'utf-8');
    const config = JSON.parse(data);
    // Ensure topLevelFolders is always an array
    if (!Array.isArray(config.topLevelFolders)) {
      config.topLevelFolders = [];
    }
    return config;
  } catch (error) {
    log.error('Error reading config:', error);
    // Return default config if file doesn't exist or is invalid
    return { topLevelFolders: [] };
  }
}

async function writeConfig(config: Config): Promise<void> {
  try {
    await fs.writeFile(CONFIG_FILE, JSON.stringify(config, null, 2));
  } catch (error) {
    log.error('Error writing config:', error);
  }
}

export async function getTopLevelFolders(): Promise<string[]> {
  log.info('Entering getTopLevelFolders');
  const config = await readConfig();
  log.info('Exiting getTopLevelFolders');
  return config.topLevelFolders;
}

export async function addTopLevelFolder(folderPath: string): Promise<void> {
  log.info(`Adding top-level folder: ${folderPath}`);
  const config = await readConfig();
  if (!config.topLevelFolders.includes(folderPath)) {
    config.topLevelFolders.push(folderPath);
    await writeConfig(config);
  }
}

export async function removeTopLevelFolder(folderPath: string): Promise<void> {
  log.info(`Removing top-level folder: ${folderPath}`);
  const config = await readConfig();
  config.topLevelFolders = config.topLevelFolders.filter(path => path !== folderPath);
  await writeConfig(config);
}
--- src/main/embeddings.ts ---

import {
  Note,
  FileNode,
  DirectoryStructures,
  Embedding,
  SimilarNote,
} from "@/renderer/shared/types";
import { ipcMain } from "electron";
import OpenAI from "openai";
import fs from "fs/promises";
import path from "path";
import { parse } from "node-html-parser";
import { getOpenAIKey } from "./fileSystem";
import { ChatCompletionMessageParam } from "openai/resources/chat";

const TEXT_EMBEDDING_MODEL = "text-embedding-ada-002";

class EmbeddingCreator {
  private openai: OpenAI;

  constructor(openai: OpenAI) {
    this.openai = openai;
  }

  async createEmbedding(content: string): Promise<Embedding> {
    return await this.openai.embeddings.create({
      model: TEXT_EMBEDDING_MODEL,
      input: content,
    });
  }

  async parseNoteForEmbedding(note: Note): Promise<string> {
    const root = parse(note.content);
    const textContent = root.textContent.trim();
    return `${note.title}\n\n${textContent}`;
  }

  async saveEmbedding(embedding: Embedding, filePath: string): Promise<void> {
    const embeddingDirPath = path.dirname(filePath);
    await fs.mkdir(embeddingDirPath, { recursive: true });
    await fs.writeFile(filePath, JSON.stringify(embedding));
  }
}

class SimilaritySearcher {
  async findEmbeddingPaths(
    directoryStructures: DirectoryStructures
  ): Promise<string[]> {
    const embeddingPaths: string[] = [];

    const traverseStructure = async (fileNode: FileNode) => {
      if (fileNode.type === "note" && fileNode.noteMetadata) {
        const embeddingPath = `${path.dirname(fileNode.fullPath)}/${
          fileNode.noteMetadata.id
        }.embedding.json`;
        try {
          await fs.access(embeddingPath);
          embeddingPaths.push(embeddingPath);
        } catch (error) {
          // Embedding file doesn't exist, skip
        }
      }
      if (fileNode.childIds) {
        for (const childId of fileNode.childIds) {
          const childNode = directoryStructures.nodes[childId];
          if (childNode) {
            await traverseStructure(childNode);
          }
        }
      }
    };

    for (const rootId of directoryStructures.rootIds) {
      const rootNode = directoryStructures.nodes[rootId];
      if (rootNode) {
        await traverseStructure(rootNode);
      }
    }

    return embeddingPaths;
  }

  async performSimilaritySearch(
    queryEmbedding: OpenAI.Embeddings.CreateEmbeddingResponse,
    embeddingPaths: string[]
  ): Promise<SimilarNote[]> {
    const results: SimilarNote[] = [];

    for (const embeddingPath of embeddingPaths) {
      const embeddingContent = await fs.readFile(embeddingPath, "utf-8");
      const embedding = JSON.parse(embeddingContent) as Embedding;
      const score = this.cosineSimilarity(
        queryEmbedding.data[0].embedding,
        embedding.data[0].embedding
      );
      const notePath = embeddingPath.replace(".embedding.json", ".json");
      const noteContent = await fs.readFile(notePath, "utf-8");
      const note = JSON.parse(noteContent) as SimilarNote;

      results.push({ ...note, score });
    }

    return results.sort((a, b) => b.score - a.score).slice(0, 10); // Return top 5 results
  }

  cosineSimilarity(a: number[], b: number[]): number {
    const dotProduct = a.reduce((sum, _, i) => sum + a[i] * b[i], 0);
    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (magnitudeA * magnitudeB);
  }
}

class RAGChat {
  private openai: OpenAI;
  private embeddingCreator: EmbeddingCreator;
  private similaritySearcher: SimilaritySearcher;

  constructor(
    openai: OpenAI,
    embeddingCreator: EmbeddingCreator,
    similaritySearcher: SimilaritySearcher
  ) {
    this.openai = openai;
    this.embeddingCreator = embeddingCreator;
    this.similaritySearcher = similaritySearcher;
  }

  async performRAGChat(
    conversation: { role: string; content: string }[],
    directoryStructures: DirectoryStructures
  ): Promise<{ role: string; content: string }> {
    try {
      // Get the last user message
      const userMessage = conversation.filter((msg) => msg.role === "user").pop();
      if (!userMessage) throw new Error("No user message found in conversation");

      // Create embedding for the query
      const queryEmbedding = await this.embeddingCreator.createEmbedding(
        userMessage.content
      );

      // Find relevant notes
      const embeddingPaths = await this.similaritySearcher.findEmbeddingPaths(
        directoryStructures
      );
      const similarNotes = await this.similaritySearcher.performSimilaritySearch(
        queryEmbedding,
        embeddingPaths
      );

      // Prepare the context for the assistant
      let contextText = "";
      for (const note of similarNotes) {
        const truncatedContent = note.content.slice(0, 2000); // Limit content length
        contextText += `Note ID: ${note.id}\nTitle: ${note.title}\nContent:\n${truncatedContent}\n\n`;
      }

      // Construct the system prompt without undefined variables
      const systemPrompt = `You are a helpful assistant. Use the provided notes to answer the user's question. When you refer to a note, include a clickable link in the format [Note Title](note://noteId).`;

      // Build the messages for OpenAI API
      const messages: ChatCompletionMessageParam[] = [
        { role: "system", content: systemPrompt },
        { role: "assistant", content: `Here are some relevant notes:\n${contextText}` },
        ...(conversation as ChatCompletionMessageParam[]),
      ];
  
      const completion = await this.openai.chat.completions.create({
        model: "gpt-4", // Corrected model name
        messages: messages,
      });
      const assistantMessage = completion.choices[0].message;
      const finishReason = completion.choices[0].finish_reason;

      if (finishReason === "content_filter") {
        console.error("Assistant's reply was blocked by content filter.");
        throw new Error("Assistant's reply was blocked due to content policy.");
      }

      return assistantMessage;
    } catch (error) {
      console.error("Error in RAG Chat:", error);
      throw error;
    }
  }
}

export const setupEmbeddingService = async (): Promise<void> => {
  const openaiApiKey = await getOpenAIKey();
  const openai = new OpenAI({ apiKey: openaiApiKey });
  const embeddingCreator = new EmbeddingCreator(openai);
  const similaritySearcher = new SimilaritySearcher();
  const ragChat = new RAGChat(openai, embeddingCreator, similaritySearcher);

  ipcMain.handle(
    "generate-note-embeddings",
    async (_, note: Note, fileNode: FileNode): Promise<Embedding> => {
      try {
        const parsedContent = await embeddingCreator.parseNoteForEmbedding(note);
        const embedding = await embeddingCreator.createEmbedding(parsedContent);
        const embeddingFullPath = path.join(
          path.dirname(fileNode.fullPath),
          `${note.id}.embedding.json`
        );
        await embeddingCreator.saveEmbedding(embedding, embeddingFullPath);
        return embedding;
      } catch (error) {
        console.error("Error generating note embeddings:", error);
        throw error;
      }
    }
  );

  ipcMain.handle(
    "perform-similarity-search",
    async (
      _,
      query: string,
      directoryStructures: DirectoryStructures
    ): Promise<SimilarNote[]> => {
      try {
        const queryEmbedding = await embeddingCreator.createEmbedding(query);
        const embeddingPaths = await similaritySearcher.findEmbeddingPaths(
          directoryStructures
        );
        return await similaritySearcher.performSimilaritySearch(
          queryEmbedding,
          embeddingPaths
        );
      } catch (error) {
        console.error("Error performing similarity search:", error);
        throw error;
      }
    }
  );

  ipcMain.handle(
    "perform-rag-chat",
    async (
      _,
      conversation: { role: string; content: string }[],
      directoryStructures: DirectoryStructures
    ): Promise<{ role: string; content: string }> => {
      return await ragChat.performRAGChat(conversation, directoryStructures);
    }
  );
};

--- src/main/logger.ts ---

import log from 'electron-log';
import path from 'path';
import { app } from 'electron';
import os from 'os';
import { createDirectoryIfNotExists } from '../renderer/shared/utils/fileUtils';

/* 
  Logging destinations:
  - Windows: C:\Users\<username>\AppData\Local\Tread\logs
  - macOS: ~/Library/Logs/Tread
  - Linux: ~/.local/share/Tread/logs

  For Linux: 
  - XDG = "X Desktop Group"; They agreed on standards for Linux desktop apps
  - including the xdgDataHome variable, which is the preferred location for app data
  - https://specifications.freedesktop.org/basedir-spec/latest/

  Some learnings/review: 
  - The logger is a singleton. The constructor is private so the class may
  only be instantiated through the getInstance method. The genInstance method 
  is static meaning it can be called on the class itself, not an instance of the class.

*/

const WINDOWS_FILE_LOG_PATH = path.join(app.getPath('userData'), 'logs');
const MACOS_FILE_LOG_PATH = path.join(os.homedir(), 'Library/Logs/Tread/tread.log');
const LINUX_FILE_LOG_PATH = process.env.XDG_DATA_HOME
  ? path.join(process.env.XDG_DATA_HOME, 'Tread/logs')
  : path.join(os.homedir(), '.local/share/Tread/logs');

class Logger {
  private static instance: Logger; 

  private constructor(){
    this.configureFileLogger();
    // this.configureConsoleLogger();
  }

  public static getInstance() {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  private configureFileLogger(){
    log.transports.file.level = 'debug'; 
    log.transports.file.format = '{y}-{m}-{d} {h}:{i}:{s}.{ms} [{level}] {text}';
    log.transports.file.maxSize = 5 * 1024 * 1024;

    const platform = os.platform();
    switch (platform) {
      case 'win32': {
        const dirPath = path.dirname(WINDOWS_FILE_LOG_PATH);
        createDirectoryIfNotExists(dirPath);
        log.transports.file.resolvePathFn = () => WINDOWS_FILE_LOG_PATH;
        break;
      }
      case 'darwin': { // macOS
        const dirPath = path.dirname(MACOS_FILE_LOG_PATH);
        createDirectoryIfNotExists(dirPath);
        log.transports.file.resolvePathFn = () => MACOS_FILE_LOG_PATH;
        break;
      }
      case 'linux': 
      default: {
        const dirPath = path.dirname(LINUX_FILE_LOG_PATH);
        createDirectoryIfNotExists(dirPath);
        log.transports.file.resolvePathFn = () => LINUX_FILE_LOG_PATH;
      }
    } 
  }

  private configureConsoleLogger() {
    log.transports.console.level = 'debug';
    log.transports.console.format = '{h}:{i}:{s}:{ms} {text}';
  }

  public log(message: string) {
    this.info(message);
  }

  public info(message: string) {
    log.info(message);
  }

  public error(message: string) {
    log.error(message);
  }

  public warn(message: string) {
    log.warn(message);
  }

  public debug(message: string) {
    log.debug(message);
  }


}

export default Logger.getInstance(); 
--- src/main/pythonBridge.ts ---

import { PythonShell } from "python-shell";
import path from "path";
import { app } from "electron";
import fs from "fs";
import { getOpenAIKey } from "./fileSystem";

export function runPythonScript(
  scriptName: string,
  args: string[] = [],
  env: Record<string, string> = {}
): Promise<any> {
  return new Promise((resolve, reject) => {
    let scriptPath: string;
    let pythonPath: string;

    if (app.isPackaged) {
      scriptPath = path.join(
        process.resourcesPath,
        "src",
        "python",
        "services",
        `${scriptName}.py`
      );
      pythonPath = path.join(
        process.resourcesPath,
        "python_venv",
        "Scripts",
        "python.exe"
      );
    } else {
      scriptPath = path.join(
        app.getAppPath(),
        "src",
        "python",
        "services",
        `${scriptName}.py`
      );
      pythonPath = path.join(
        app.getAppPath(),
        "python_venv",
        "Scripts",
        "python.exe"
      );
    }

    if (process.platform !== "win32") {
      pythonPath = pythonPath.replace("Scripts", "bin").replace(".exe", "");
    }

    console.log("Attempting to run Python script at:", scriptPath);
    console.log("Using Python interpreter at:", pythonPath);

    if (!fs.existsSync(scriptPath)) {
      console.error("Python script not found at:", scriptPath);
      reject(new Error(`Python script not found: ${scriptPath}`));
      return;
    }

    PythonShell.run(scriptPath, { pythonPath, args, env })
      .then((results) => {
        console.log("Python script results:", results);
        resolve(JSON.parse(results[0]));
      })
      .catch((err) => {
        console.error("Error running Python script:", err);
        reject(err);
      });
  });
}

export async function runEmbeddingScript(
  action: string,
  ...args: string[]
): Promise<any> {
  const apiKey = await getOpenAIKey();

  console.log({
    embeddings: "embeddings",
    action,
    ...args,
    OPEN_AI_API_KEY: apiKey
  })

  return runPythonScript("embeddings", [action, ...args], {
    OPENAI_API_KEY: apiKey,
  });
}

--- src/main/fileSystem.ts ---

import { ipcMain, app } from "electron";
import fs from "fs/promises";
import path from "path";
import { Config, DirectoryEntry, Note, NoteMetadata } from "@/renderer/shared/types";
import { v4 as uuidv4 } from "uuid";
import logger from "./logger";
const NOTES_DIR = path.join(app.getPath("userData"), "notes");

// Special delimiter used for parsing notes from non-notes
const NOTE_DELIMITER = "___";

// Create a config file path
const CONFIG_FILE = path.join(app.getPath("userData"), "config.json");

export const setupFileSystem = async () => {
  // Ensure the notes directory exists
  await fs.mkdir(NOTES_DIR, { recursive: true });

  // Ensure the config file exists
  try {
    await fs.access(CONFIG_FILE);
  } catch {
    await fs.writeFile(CONFIG_FILE, JSON.stringify({}));
  }

  ipcMain.handle("get-directory-structure", async (_, dirPath: string) => {
    try {
      const dirStructure = await loadDirectoryStructure(dirPath);
      return dirStructure;
    } catch (error) {
      console.error(`Error loading directory structure for dirPath=${dirPath}`);
      throw error;
    }
  });

  ipcMain.handle("load-note", async (_, notePath: string) => {
    try {
      const noteContent = await fs.readFile(notePath, "utf-8");
      const note: Note = JSON.parse(noteContent);
      return note;
    } catch (error) {
      console.error("Error loading note:", error);
      throw error;
    }
  });

  ipcMain.handle("save-note", async (_, note: Note, dirPath: string) => {
    try {
      const fileName = `${note.id}.json`;
      const filePath = path.join(dirPath, fileName);
      await fs.mkdir(dirPath, { recursive: true });
      await fs.writeFile(filePath, JSON.stringify(note));
      console.log(`Note saved successfully at filePath=${filePath}`);
      return filePath;
    } catch (error) {
      console.error("Error saving note:", error);
      throw error;
    }
  });

  ipcMain.handle("delete-file-node", async (_, fileNodeType: string, fileNodePath: string) => {
  try {
    if (fileNodeType === "directory") {
      // Deletes the directory and all its contents, including embedding files
      await fs.rm(fileNodePath, { recursive: true, force: true });
    } else if (fileNodeType === "note") {
      // Delete the note file
      await fs.unlink(fileNodePath);

      // Construct the embedding file path
      const embeddingFilePath = fileNodePath.replace(/\.json$/, ".embedding.json");

      // Attempt to delete the embedding file
      try {
        await fs.unlink(embeddingFilePath);
        console.log(`Embedding file deleted at path: ${embeddingFilePath}`);
      } catch (error: any) {
        if (error.code !== "ENOENT") {
          // Log errors other than file not existing
          console.error(`Error deleting embedding file at path: ${embeddingFilePath}`, error);
        }
        // If the embedding file doesn't exist, ignore the error
      }
    }
  } catch (err) {
    console.error(`Error deleting fileNode with path: ${fileNodePath}`, err);
  }
  });


  ipcMain.handle("create-directory", async (_, dirPath: string) => {
    try {
      await fs.mkdir(dirPath, { recursive: true });
    } catch (error) {
      console.error("Error creating directory:", error);
      throw error;
    }
  });

  ipcMain.handle("delete-directory", async (_, dirPath: string) => {
    try {
      await fs.rm(dirPath, { recursive: true, force: true });
    } catch (error) {
      console.error("Error deleting directory:", error);
      throw error;
    }
  });

  ipcMain.handle("get-note-path", async (_, noteId: string) => {
    return path.join(NOTES_DIR, `${noteId}.json`);
  });

  ipcMain.handle("get-openai-key", async () => {
    try {
      const config = await fs.readFile(CONFIG_FILE, "utf-8");
      return JSON.parse(config).openaiApiKey || "";
    } catch (error) {
      console.error("Error reading OpenAI API key:", error);
      return "";
    }
  });

  ipcMain.handle("set-openai-key", async (_, key: string) => {
    try {
      let config: Config = {};
      try {
        const configContent = await fs.readFile(CONFIG_FILE, "utf-8");
        config = JSON.parse(configContent);
      } catch (error) {
        // If the file doesn't exist or is invalid, start with an empty config
        config = {};
      }
      config.openaiApiKey = key;
      await fs.writeFile(CONFIG_FILE, JSON.stringify(config, null, 2));
    } catch (error) {
      console.error("Error saving OpenAI API key:", error);
      throw error;
    }
  });
};

// Recursively create a tree representation of a directory
const loadDirectoryStructure = async (dirPath: string): Promise<DirectoryEntry> => {
  console.log(`Loading directory structure for path: ${dirPath}`);
  const dirName = path.basename(dirPath);
  const structure: DirectoryEntry = {
    name: dirName,
    type: "directory",
    fullPath: dirPath,
    children: [],
  };

  try {
    const entries = await fs.readdir(dirPath, { withFileTypes: true });
    logger.debug(`Found ${entries.length} entries in ${dirPath}`);

    for (const entry of entries) {
      const childPath = path.join(dirPath, entry.name);
      logger.debug(`Processing entry: ${entry.name} in ${dirPath}`);

      if (entry.isDirectory()) {
        const childStructure = await loadDirectoryStructure(childPath);
        structure.children?.push(childStructure);
      } else if (
        entry.isFile() &&
        entry.name.endsWith(".json") &&
        !entry.name.endsWith(".embedding.json")
      ) {
        try {
          const noteContent = await fs.readFile(childPath, "utf-8");
          const note: Note = JSON.parse(noteContent);
          structure.children?.push({
            name: note.title,
            type: "note",
            noteMetadata: {
              id: note.id,
              title: note.title,
            },
            fullPath: childPath,
          });
        } catch (error) {
          console.error(`Error reading note file ${childPath}:`, error);
        }
      }
    }

    return structure;
  } catch (error) {
    console.error(`Error loading directory structure for ${dirPath}:`, error);
    throw error;
  }
};

export const getOpenAIKey = async (): Promise<string> => {
  try {
    const configContent = await fs.readFile(CONFIG_FILE, "utf-8");
    const config = JSON.parse(configContent);
    return config.openaiApiKey || "";
  } catch (error) {
    console.error("Error reading OpenAI API key:", error);
    return "";
  }
};
