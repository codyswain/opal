Tree structure of src folder:
src
â”œâ”€â”€ App.tsx
â”œâ”€â”€ features
â”‚Â Â  â”œâ”€â”€ feed
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Feed.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.tsx
â”‚Â Â  â”œâ”€â”€ navbar
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Navbar.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ NavbarItem.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ navbarItems.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useNavbarItems.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.tsx
â”‚Â Â  â”œâ”€â”€ notes
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ BottomPane.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteEditor.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteExplorer.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteExplorerContent.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteExplorerContextMenu.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ NoteExplorerHeader.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Notes.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ RelatedNotes.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ context
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ notesContext.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ useNoteExplorerContextMenu.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useNotes.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ reducers
â”‚Â Â  â”œâ”€â”€ settings
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ Settings.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ context
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ SettingsContext.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ types
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ utils
â”‚Â Â  â”‚Â Â      â””â”€â”€ settingsStorage.ts
â”‚Â Â  â””â”€â”€ theme
â”‚Â Â      â”œâ”€â”€ components
â”‚Â Â      â”‚Â Â  â””â”€â”€ ThemeToggle.tsx
â”‚Â Â      â”œâ”€â”€ config
â”‚Â Â      â”‚Â Â  â””â”€â”€ themeConfig.ts
â”‚Â Â      â”œâ”€â”€ context
â”‚Â Â      â”‚Â Â  â””â”€â”€ ThemeContext.tsx
â”‚Â Â      â”œâ”€â”€ hooks
â”‚Â Â      â”‚Â Â  â””â”€â”€ useTheme.ts
â”‚Â Â      â”œâ”€â”€ index.tsx
â”‚Â Â      â””â”€â”€ utils
â”‚Â Â          â””â”€â”€ themeUtils.ts
â”œâ”€â”€ index.css
â”œâ”€â”€ main
â”‚Â Â  â”œâ”€â”€ configManager.ts
â”‚Â Â  â”œâ”€â”€ embeddings.ts
â”‚Â Â  â”œâ”€â”€ fileSystem.ts
â”‚Â Â  â””â”€â”€ pythonBridge.ts
â”œâ”€â”€ main.ts
â”œâ”€â”€ preload.ts
â”œâ”€â”€ python
â”‚Â Â  â””â”€â”€ services
â”‚Â Â      â””â”€â”€ embeddings.py
â”œâ”€â”€ renderer.tsx
â”œâ”€â”€ services
â”œâ”€â”€ shared
â”‚Â Â  â”œâ”€â”€ components
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Button.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Card.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ContextMenu
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ContextMenu.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ContextMenuItem.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ScrollArea.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Tabs
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ CustomTabBar.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Tabs.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TabsContent.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TabsList.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TabsTrigger.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ index.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Toast.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Toggle.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Tooltip.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ input.tsx
â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ useDebounce.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ useLocalStorage.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ useResizablePane.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ useResizableSidebar.ts
â”‚Â Â  â”œâ”€â”€ types
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.ts
â”‚Â Â  â””â”€â”€ utils
â”‚Â Â      â””â”€â”€ index.ts
â””â”€â”€ styles
    â”œâ”€â”€ GlobalStyles.ts
    â””â”€â”€ common
        â””â”€â”€ components.ts

36 directories, 63 files


File contents:

--- src/renderer.tsx ---

import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "@/App";
import "@/index.css";
import {
  Note,
  FileNode,
  DirectoryEntry,
  SimilarNote,
  Embedding,
  DirectoryStructures,
} from "@/shared/types";

declare global {
  interface Window {
    electron: {
      saveNote: (note: Note, dirPath: string) => Promise<string>;
      deleteNote: (noteId: string, dirPath: string) => Promise<void>;
      minimize: () => void;
      maximize: () => void;
      close: () => void;
      getOpenAIKey: () => Promise<string>;
      setOpenAIKey: (key: string) => Promise<void>;
      getNotePath: (noteId: string) => Promise<string>;
      createDirectory: (dirPath: string) => Promise<void>;
      deleteDirectory: (dirPath: string) => Promise<void>;
      getTopLevelFolders: () => Promise<string[]>;
      addTopLevelFolder: (folderPath: string) => Promise<string[]>;
      removeTopLevelFolder: (folderPath: string) => Promise<string[]>;
      openFolderDialog: () => Promise<string | null>;
      getDirectoryStructure: (dirPath: string) => Promise<DirectoryEntry>;
      loadNote: (notePath: string) => Promise<Note>;
      deleteFileNode: (
        fileNodeType: string,
        fileNodePath: string
      ) => Promise<void>;
      generateNoteEmbeddings: (
        note: Note,
        fileNode: FileNode
      ) => Promise<Embedding>;
      findSimilarNotes: (
        query: string,
        directoryStructures: DirectoryStructures
      ) => Promise<SimilarNote[]>;
    };
  }
}

createRoot(document.getElementById("root") as HTMLElement).render(
  <StrictMode>
    <App />
  </StrictMode>
);

console.log(
  'ðŸ‘‹ This message is being logged by "renderer.tsx", included via Vite'
);

--- src/App.tsx ---

import React, { useState } from "react";
import { BrowserRouter as Router, Route, Routes } from "react-router-dom";
import "@/index.css";

import { ThemeProvider } from "@/features/theme";
import { NotesProvider } from "@/features/notes/context/notesContext";
import { TooltipProvider } from "@/shared/components/Tooltip";
import { Toaster } from "@/shared/components/Toast";
import { Navbar, navbarItems } from "@/features/navbar";
import { Feed } from "@/features/feed";
import { Notes } from "@/features/notes";
import { Settings, SettingsProvider } from "@/features/settings";

const App: React.FC = () => {
  const [isLeftSidebarOpen, setIsLeftSidebarOpen] = useState(true);
  const [isRightSidebarOpen, setIsRightSidebarOpen] = useState(true);
  const [isBottomPaneOpen, setIsBottomPaneOpen] = useState(true);

  const toggleLeftSidebar = () => setIsLeftSidebarOpen(!isLeftSidebarOpen);
  const toggleRightSidebar = () => setIsRightSidebarOpen(!isRightSidebarOpen);
  const toggleBottomPane = () => setIsBottomPaneOpen(!isBottomPaneOpen);

  return (
    <ThemeProvider>
      <SettingsProvider>
        <TooltipProvider>
          <NotesProvider>
            <Toaster />
            <Router>
              <div className="flex flex-col h-screen">
                <Navbar
                  toggleLeftSidebar={toggleLeftSidebar}
                  toggleRightSidebar={toggleRightSidebar}
                  toggleBottomPane={toggleBottomPane}
                  isLeftSidebarOpen={isLeftSidebarOpen}
                  isRightSidebarOpen={isRightSidebarOpen}
                  isBottomPaneOpen={isBottomPaneOpen}
                  items={navbarItems}
                />
                <main className="flex-grow pt-10">
                  <Routes>
                    <Route path="/" element={<Feed />} />
                    <Route
                      path="/notes"
                      element={
                        <Notes
                          isLeftSidebarOpen={isLeftSidebarOpen}
                          isRightSidebarOpen={isRightSidebarOpen}
                          isBottomPaneOpen={isBottomPaneOpen}
                          setIsLeftSidebarOpen={setIsLeftSidebarOpen}
                          setIsRightSidebarOpen={setIsRightSidebarOpen}
                          setIsBottomPaneOpen={setIsBottomPaneOpen}
                        />
                      }
                    />
                    <Route path="/settings" element={<Settings />} />
                  </Routes>
                </main>
              </div>
            </Router>
          </NotesProvider>
        </TooltipProvider>
      </SettingsProvider>
    </ThemeProvider>
  );
};

export default App;

--- src/main.ts ---

import { app, BrowserWindow, ipcMain, dialog } from "electron";
import path from "path";
import { setupFileSystem } from "./main/fileSystem";
import {
  addTopLevelFolder,
  getTopLevelFolders,
  removeTopLevelFolder,
} from "./main/configManager";
import { setupEmbeddingService } from "./main/embeddings";

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

let mainWindow: BrowserWindow | null = null;

const isDevelopment = process.env.NODE_ENV === "development";

const CSP = [
  "default-src 'self'",
  isDevelopment
    ? "script-src 'self' 'unsafe-inline' 'unsafe-eval'"
    : "script-src 'self'",
  "style-src 'self' 'unsafe-inline'",
  "img-src 'self' data:",
  "font-src 'self' data:",
  isDevelopment ? "connect-src 'self' ws:" : "connect-src 'self'",
];

const createWindow = () => {
  mainWindow = new BrowserWindow({
    width: 800,
    height: 600,
    frame: false,
    webPreferences: {
      preload: path.join(__dirname, "preload.js"),
      nodeIntegration: false,
      contextIsolation: true,
      sandbox: true,
    },
  });

  // Set Content Security Policy
  mainWindow.webContents.session.webRequest.onHeadersReceived(
    (details, callback) => {
      callback({
        responseHeaders: {
          ...details.responseHeaders,
          "Content-Security-Policy": [CSP.join("; ")],
        },
      });
    }
  );

  // Load the main page (which will contain the navigation)
  if (MAIN_WINDOW_VITE_DEV_SERVER_URL) {
    mainWindow.loadURL(MAIN_WINDOW_VITE_DEV_SERVER_URL);
  } else {
    mainWindow.loadFile(
      path.join(__dirname, `../renderer/${MAIN_WINDOW_VITE_NAME}/index.html`)
    );
  }

  // Open the DevTools only in development mode
  if (process.env.NODE_ENV === "development") {
    mainWindow.webContents.openDevTools();
  }
};

// Set up IPC listeners for window controls
ipcMain.on("minimize-window", () => {
  mainWindow?.minimize();
});

ipcMain.on("maximize-window", () => {
  if (mainWindow?.isMaximized()) {
    mainWindow.unmaximize();
  } else {
    mainWindow?.maximize();
  }
});

ipcMain.on("close-window", () => {
  mainWindow?.close();
});

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(async () => {
  await setupFileSystem();
  await setupEmbeddingService();
  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On macOS it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Add error handling
process.on("uncaughtException", (error) => {
  console.error("Uncaught exception:", error);
  // Optionally, you can quit the app or show an error dialog
});

// IPC handlers for top-level folder management
ipcMain.handle("get-top-level-folders", getTopLevelFolders);
ipcMain.handle("add-top-level-folder", async (_, folderPath) => {
  await addTopLevelFolder(folderPath);
  return getTopLevelFolders(); // Return updated list
});
ipcMain.handle("remove-top-level-folder", async (_, folderPath) => {
  await removeTopLevelFolder(folderPath);
  return getTopLevelFolders(); // Return updated list
});

// Folder selection dialog handler remains the same
ipcMain.handle("open-folder-dialog", async () => {
  const result = await dialog.showOpenDialog({
    properties: ["openDirectory", "createDirectory"],
    buttonLabel: "Select Folder",
    title: "Select a folder to add as a top-level folder",
  });

  if (!result.canceled && result.filePaths.length > 0) {
    return result.filePaths[0];
  }
  return null;
});

--- src/python/services/embeddings.py ---

import sys
import json
import os
from typing import Dict, List
import numpy as np
import faiss
from openai import OpenAI

# Provided through from fileSystem.ts through pythonBridge.ts
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    raise ValueError("OpenAI API key not found in environment variables")
client = OpenAI(api_key=OPENAI_API_KEY)

# Get the notes directory from command-line arguments
NOTES_DIR = sys.argv[1]


def get_embedding(text: str) -> List[float]:
    response = client.embeddings.create(model="text-embedding-ada-002", input=text)
    return response.data[0].embedding


def compute_and_store_embedding(embedding_path: str, note_content: str) -> None:
    embedding = get_embedding(note_content)
    with open(embedding_path, "w") as f:
        json.dump({"embedding": embedding}, f)

def find_similar_notes(query_embedding: List[float], top_k: int = 5) -> List[str]:
    embeddings: List[List[float]] = []
    note_ids: List[str] = []
    for filename in os.listdir(NOTES_DIR):
        if filename.endswith(".embedding.json"):
            note_id = filename.split(".")[0]
            with open(os.path.join(NOTES_DIR, filename), "r") as f:
                data: Dict[str, List[float]] = json.load(f)
                embeddings.append(data["embedding"])
                note_ids.append(note_id)

    if not embeddings:
        return []

    embeddings_array = np.array(embeddings).astype("float32")

    dimension = len(embeddings[0])
    index = faiss.IndexFlatL2(dimension)
    index.add(embeddings_array)

    distances, indices = index.search(
        np.array([query_embedding]).astype("float32"), top_k
    )

    return [note_ids[i] for i in indices[0]]


if __name__ == "__main__":
    action = sys.argv[2]
    if action == "compute":
        embedding_path = sys.argv[3]
        print(f"embedding path {embedding_path}")
        note_content = sys.argv[4]
        print(f"note content {note_content}")
        compute_and_store_embedding(embedding_path, note_content)
        print(json.dumps({"success": True}))
    # elif action == "find_similar":
    #     query = sys.argv[3]
    #     query_embedding = get_embedding(query)
    #     similar_notes = find_similar_notes(query_embedding)
    #     print(json.dumps({"similar_notes": similar_notes}))

--- src/features/settings/index.tsx ---

export { Settings } from './components/Settings';
export { SettingsProvider, useSettings } from './context/SettingsContext';
export type { Settings as SettingsType, SettingsContextType } from './types';
--- src/features/settings/types/index.ts ---

export interface Settings {
  openAIKey: string;
}

export interface SettingsContextType {
  settings: Settings;
  updateSettings: (newSettings: Partial<Settings>) => Promise<void>;
}
--- src/features/settings/context/SettingsContext.tsx ---

import React, { createContext, useContext, useState, useEffect } from 'react';
import { SettingsContextType, Settings } from '../types';
import { getSettings, saveSettings } from '../utils/settingsStorage';

const SettingsContext = createContext<SettingsContextType | undefined>(undefined);

export const SettingsProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [settings, setSettings] = useState<Settings>({
    openAIKey: '',
  });

  useEffect(() => {
    const loadSettings = async () => {
      const savedSettings = await getSettings();
      setSettings(savedSettings);
    };
    loadSettings();
  }, []);

  const updateSettings = async (newSettings: Partial<Settings>) => {
    const updatedSettings = { ...settings, ...newSettings };
    setSettings(updatedSettings);
    await saveSettings(updatedSettings);
  };

  return (
    <SettingsContext.Provider value={{ settings, updateSettings }}>
      {children}
    </SettingsContext.Provider>
  );
};

export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (context === undefined) {
    throw new Error('useSettings must be used within a SettingsProvider');
  }
  return context;
};
--- src/features/settings/utils/settingsStorage.ts ---

import { Settings } from '../types';

export const getSettings = async (): Promise<Settings> => {
  const openAIKey = await window.electron.getOpenAIKey();
  return { openAIKey: openAIKey || '' };
};

export const saveSettings = async (settings: Settings): Promise<void> => {
  await window.electron.setOpenAIKey(settings.openAIKey);
};
--- src/features/settings/components/Settings.tsx ---

import React, { useState } from "react";
import { Input } from "@/shared/components/Input";
import { Button } from "@/shared/components/Button";
import { Eye, EyeOff } from "lucide-react";
import { useSettings } from "../context/SettingsContext";

export const Settings: React.FC = () => {
  const { settings, updateSettings } = useSettings();
  const [showApiKey, setShowApiKey] = useState(false);

  const handleSave = () => {
    updateSettings({ openAIKey: settings.openAIKey });
  };

  const toggleApiKeyVisibility = () => {
    setShowApiKey(!showApiKey);
  };

  return (
    <div className="container mx-auto p-4 mt-2">
      <h2 className="text-2xl font-bold mb-4">Settings</h2>
      <div className="mb-4">
        <label htmlFor="apiKey" className="block text-sm font-medium mb-1">
          OpenAI API Key
        </label>
        <div className="flex items-center">
          <div className="flex-grow">
            <Input
              id="apiKey"
              type={showApiKey ? "text" : "password"}
              value={settings.openAIKey}
              onChange={(e) => updateSettings({ openAIKey: e.target.value })}
              className="w-full"
              placeholder="Enter your OpenAI API key"
            />
          </div>
          <button
            type="button"
            onClick={toggleApiKeyVisibility}
            className="ml-2 p-2 focus:outline-none"
          >
            {showApiKey ? (
              <EyeOff className="h-5 w-5 text-gray-400" />
            ) : (
              <Eye className="h-5 w-5 text-gray-400" />
            )}
          </button>
        </div>
      </div>
      <Button onClick={handleSave}>Save</Button>
    </div>
  );
};
--- src/features/navbar/index.tsx ---

import Navbar from './components/Navbar';
import navbarItems from './config/navbarItems';

export {
  Navbar,
  navbarItems
};
--- src/features/navbar/config/navbarItems.ts ---

import { NavbarItemProps } from "../components/NavbarItem";
import { Home, Notebook } from "lucide-react";

const navbarItems: NavbarItemProps[] = [
  { to: "/", icon: Home, text: "Home" },
  { to: "/notes", icon: Notebook, text: "Notes" }
];

export default navbarItems;
--- src/features/navbar/components/Navbar.tsx ---

import React from "react";
import { Link, useLocation } from "react-router-dom";
import { Button } from "@/shared/components/Button";
import { NavbarItem, NavbarItemProps } from "./NavbarItem";
import {
  Minus,
  PanelLeftClose,
  PanelLeftOpen,
  PanelRightClose,
  PanelRightOpen,
  Settings,
  Square,
  X,
  ChevronsUp,
  ChevronsDown,
} from "lucide-react";
import { ThemeToggle } from "@/features/theme";

interface NavbarProps {
  toggleLeftSidebar: () => void;
  toggleRightSidebar: () => void;
  toggleBottomPane: () => void;
  isLeftSidebarOpen: boolean;
  isRightSidebarOpen: boolean;
  isBottomPaneOpen: boolean;
  items: NavbarItemProps[];
}

const Navbar: React.FC<NavbarProps> = ({
  toggleLeftSidebar,
  toggleRightSidebar,
  toggleBottomPane,
  isLeftSidebarOpen,
  isRightSidebarOpen,
  isBottomPaneOpen,
  items,
}) => {
  const location = useLocation();

  const handleWindowAction = (action: "minimize" | "maximize" | "close") => {
    window.electron[action]();
  };

  const renderWindowControls = () => (
    <div className="flex items-center space-x-2 no-drag">
      {[
        { action: "close", icon: X },
        { action: "minimize", icon: Minus },
        { action: "maximize", icon: Square },
      ].map(({ action, icon: Icon }) => (
        <Button
          key={action}
          variant="ghost"
          size="icon"
          className="h-8 w-8"
          onClick={() =>
            handleWindowAction(action as "minimize" | "maximize" | "close")
          }
        >
          <span className="sr-only">{action}</span>
          <Icon className="h-4 w-4 mr-2" />
        </Button>
      ))}
    </div>
  );

  const renderNavItems = () => (
    <ul className="flex items-center space-x-2 no-drag mx-auto">
      {items.map((item) => (
        <NavbarItem
          key={item.to}
          {...item}
          isActive={location.pathname === item.to}
        />
      ))}
    </ul>
  );

  const renderSidebarControls = () => (
    <div className="flex items-center space-x-2 no-drag">
      <ThemeToggle />
      <Button
        variant="ghost"
        size="icon"
        className="h-8 w-8"
        onClick={toggleLeftSidebar}
      >
        {isLeftSidebarOpen ? (
          <PanelLeftClose className="h-4 w-4" />
        ) : (
          <PanelLeftOpen className="h-4 w-4" />
        )}
      </Button>
      <Button
        variant="ghost"
        size="icon"
        className="h-8 w-8"
        onClick={toggleRightSidebar}
      >
        {isRightSidebarOpen ? (
          <PanelRightClose className="h-4 w-4" />
        ) : (
          <PanelRightOpen className="h-4 w-4" />
        )}
      </Button>
      <Button
        variant="ghost"
        size="icon"
        className="h-8 w-8"
        onClick={toggleBottomPane}
      >
        {isBottomPaneOpen ? (
          <ChevronsDown className="h-4 w-4" />
        ) : (
          <ChevronsUp className="h-4 w-4" />
        )}
      </Button>
      <Link to="/settings">
        <Button variant="ghost" size="icon" className="h-8 w-8">
          <Settings className="h-4 w-4" />
        </Button>
      </Link>
    </div>
  );

  return (
    <nav className="fixed top-0 left-0 right-0 h-12 bg-background border-b border-border flex items-center justify-between px-4 z-20 drag-handle">
      {renderWindowControls()}
      {renderNavItems()}
      {renderSidebarControls()}
    </nav>
  );
};

export default Navbar;

--- src/features/navbar/components/NavbarItem.tsx ---

import React from "react";
import { Link } from "react-router-dom";
import { LucideIcon } from "lucide-react";

export interface NavbarItemProps {
  to: string;
  icon: LucideIcon;
  text: string;
  isActive?: boolean;
}

export const NavbarItem: React.FC<NavbarItemProps> = ({ to, icon: Icon, text, isActive }) => (
  <li>
    <Link
      to={to}
      className={`flex items-center px-3 py-1 rounded-md text-sm ${
        isActive ? "bg-accent text-accent-foreground" : "hover:bg-accent/50"
      }`}
    >
      <Icon className="h-4 w-4 mr-2" />
      {text}
    </Link>
  </li>
);
--- src/features/navbar/hooks/useNavbarItems.ts ---

import { useMemo } from 'react';
import navbarItems from '../config/navbarItems';

export const useNavbarItems = () => {
  return useMemo(() => navbarItems, []);
};
--- src/features/notes/index.tsx ---

import Notes from './components/Notes';
import NoteEditor from './components/NoteEditor';
import RelatedNotes from './components/RelatedNotes';
import { useNotes } from './hooks/useNotes';

export {
  Notes,
  NoteEditor,
  RelatedNotes,
  useNotes
};
--- src/features/notes/context/notesContext.tsx ---

// src/features/notes/context/notesContext.tsx

import React, { createContext, useContext, ReactNode } from 'react';
import { useNotes } from '../hooks/useNotes';

const NotesContext = createContext<ReturnType<typeof useNotes> | undefined>(undefined);

export const NotesProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const notesData = useNotes();
  
  return (
    <NotesContext.Provider value={notesData}>
      {children}
    </NotesContext.Provider>
  );
};

export const useNotesContext = () => {
  const context = useContext(NotesContext);
  if (context === undefined) {
    throw new Error('useNotesContext must be used within a NotesProvider');
  }
  return context;
};

--- src/features/notes/components/NoteExplorer.tsx ---

// src/features/notes/components/NoteExplorer.tsx

import React from "react";
import { Settings } from "lucide-react";
import { useResizableSidebar } from "@/shared/hooks/useResizableSidebar";
import { Button } from "@/shared/components/Button";
import { toast } from "@/shared/components/Toast";
import { cn } from "@/shared/utils";
import { useNoteExplorerContextMenu } from "../hooks/useNoteExplorerContextMenu";
import { NoteExplorerHeader } from "./NoteExplorerHeader";
import NoteExplorerContextMenu from "./NoteExplorerContextMenu";
import { NoteExplorerContent } from "./NoteExplorerContent";
import { useNotesContext } from "../context/notesContext";

interface NoteExplorerProps {
  isOpen: boolean;
  onResize: (width: number) => void;
  onClose: () => void;
}

const NoteExplorer: React.FC<NoteExplorerProps> = ({
  isOpen,
  onResize,
  onClose
}) => {
  const { width, sidebarRef, startResizing } = useResizableSidebar({
    minWidth: 100,
    maxWidth: 400,
    defaultWidth: 256,
    isOpen,
    onResize,
    onClose,
    side: "left",
  });

  const { contextMenu, handleContextMenu, closeContextMenu } = useNoteExplorerContextMenu();
  const {
    directoryStructures,
    createNote,
    activeFileNode,
    setActiveFileNode,
    deleteFileNode,
    handleCreateFolder,
    expandedDirs,
    toggleDirectory,
    newFolderState,
    isLoading,
    error
  } = useNotesContext();                              

  const handleDelete = () => {
    if (contextMenu?.fileNode) {
      deleteFileNode(contextMenu.fileNode)
    }
  }

  return (
    <div
      ref={sidebarRef}
      className={cn(
        "fixed top-12 left-0 h-[calc(100vh-3rem)] bg-background border-r border-border transition-all duration-300 z-10 overflow-hidden",
        isOpen ? `w-[${width}px]` : "w-0"
      )}
      style={{ width: isOpen ? width : 0 }}
    >
      <NoteExplorerContextMenu
        contextMenu={contextMenu}
        onClose={closeContextMenu}
        onDelete={handleDelete}
        onCopyFilePath={() => {console.log('IMPLEMENT COPY FILE PATH')}}
        onOpenNoteInNewTab={() => {console.log('IMPLEMENT OPEN NOTE IN NEW TAB')}}
      />
      <NoteExplorerHeader
        onCreateNote={() => createNote(activeFileNode?.fullPath || "/")}
        onCreateFolder={() => handleCreateFolder(activeFileNode || null)}
      />
      <NoteExplorerContent
        isLoadingFolders={isLoading}
        loadError={error}
        directoryStructures={directoryStructures}
        selectedFileNode={activeFileNode}
        onSelectNote={setActiveFileNode}
        handleContextMenu={handleContextMenu}
      />
      <div className="absolute bottom-2 right-2">
        <Button
          variant="ghost"
          size="icon"
          className="h-8 w-8"
          onClick={() => toast("Settings feature is not implemented yet")}
          title="Settings"
        >
          <Settings className="h-4 w-4" />
        </Button>
      </div>
      <div
        onMouseDown={startResizing}
        className="absolute top-0 right-0 w-1 h-full cursor-ew-resize hover:bg-accent/50"
        style={{ right: "-1px" }}
      />
    </div>
  );
};

export default NoteExplorer;

--- src/features/notes/components/Notes.tsx ---

import React, { useState } from "react";
import RelatedNotes from "./RelatedNotes";
import NoteEditor from "./NoteEditor";
import NoteExplorer from "./NoteExplorer";
import BottomPane from "./BottomPane";
import { useNotesContext } from "../context/notesContext";

const Notes: React.FC<{
  isLeftSidebarOpen: boolean;
  isRightSidebarOpen: boolean;
  isBottomPaneOpen: boolean;
  setIsLeftSidebarOpen: (isOpen: boolean) => void;
  setIsRightSidebarOpen: (isOpen: boolean) => void;
  setIsBottomPaneOpen: (isOpen: boolean) => void;
}> = ({
  isLeftSidebarOpen,
  isRightSidebarOpen,
  isBottomPaneOpen,
  setIsLeftSidebarOpen,
  setIsRightSidebarOpen,
  setIsBottomPaneOpen,
}) => {
  const [leftSidebarWidth, setLeftSidebarWidth] = useState(256);
  const [rightSidebarWidth, setRightSidebarWidth] = useState(256);
  const [bottomPaneHeight, setBottomPaneHeight] = useState(256);
  const { activeNote } = useNotesContext();

  return (
    <div className="flex h-screen bg-background text-foreground overflow-hidden">
      <NoteExplorer
        isOpen={isLeftSidebarOpen}
        onResize={setLeftSidebarWidth}
        onClose={() => setIsLeftSidebarOpen(false)}
      />
      <main
        className="flex-grow flex flex-col overflow-hidden"
        style={{
          marginLeft: isLeftSidebarOpen ? `${leftSidebarWidth}px` : "0",
          marginRight: isRightSidebarOpen ? `${rightSidebarWidth}px` : "0",
          marginBottom: isBottomPaneOpen ? `${bottomPaneHeight}px` : "0",
          transition: "margin 0.3s ease-in-out",
        }}
      >
        {activeNote ? (
          <NoteEditor note={activeNote} />
        ) : (
          <div className="flex w-full h-full justify-center items-center">
            Please select a note
          </div>
        )}
      </main>
      <RelatedNotes
        isOpen={isRightSidebarOpen}
        onResize={setRightSidebarWidth}
        onClose={() => setIsRightSidebarOpen(false)}
      />
      <BottomPane
        isOpen={isBottomPaneOpen}
        onResize={setBottomPaneHeight}
        onClose={() => setIsBottomPaneOpen(false)}
      />
    </div>
  );
};

export default Notes;

--- src/features/notes/components/NoteExplorerContent.tsx ---

// src/features/notes/components/NoteExplorerContent.tsx

import React, { useEffect, useRef } from "react";
import { ScrollArea } from "@/shared/components/ScrollArea";
import { Loader, ChevronDown, ChevronRight, Folder, File } from "lucide-react";
import { Input } from "@/shared/components/input";
import { Button } from "@/shared/components/Button";
import { cn } from "@/shared/utils";
import { DirectoryStructures, FileNode } from "@/shared/types";
import { useNotesContext } from "../context/notesContext";

interface NoteExplorerContentProps {
  isLoadingFolders: boolean;
  loadError: string | null;
  directoryStructures: DirectoryStructures;
  selectedFileNode: FileNode | null;
  onSelectNote: (file: FileNode) => void;
  handleContextMenu: (
    e: React.MouseEvent,
    fileNode: FileNode
  ) => void;
}

export const NoteExplorerContent: React.FC<NoteExplorerContentProps> = ({
  isLoadingFolders,
  loadError,
  directoryStructures,
  selectedFileNode,
  onSelectNote,
  handleContextMenu,
}) => {
  const { toggleDirectory, expandedDirs, setActiveFileNodeId, activeFileNodeId } = useNotesContext();
  const { newFolderState } = useNotesContext();

  const activeFileNode = activeFileNodeId ? directoryStructures.nodes[activeFileNodeId] : null;

  // For the folder that renders when creating a new folder
  const newFolderInputRef = useRef<HTMLInputElement>(null);
  useEffect(() => {
    if (newFolderState.isCreatingFolder) {
      newFolderInputRef.current?.focus();
    }
  }, [newFolderState.isCreatingFolder]);
  const handleNewFolderKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      newFolderState.confirmCreateFolder();
    } else if (e.key === 'Escape') {
      newFolderState.cancelCreateFolder();
    }
  };

  const renderFileNode = (nodeId: string, depth = 0) => {
    const node = directoryStructures.nodes[nodeId];
    if (!node) return null;

    const isExpanded = expandedDirs.has(node.id);
    const isSelected = selectedFileNode?.id === node.id;

    if (node.type === "directory") {
      return (
        <div key={node.id}>
          <div
            className="flex items-center cursor-pointer hover:bg-accent/50 py-1 px-2"
            style={{ marginLeft: depth * 16 }}
            onClick={(e) => {
              e.preventDefault();
              e.stopPropagation();
              toggleDirectory(node);
            }}
            onContextMenu={(e) => handleContextMenu(e, node)}
          >
            {isExpanded ? (
              <ChevronDown className="h-4 w-4 mr-1" />
            ) : (
              <ChevronRight className="h-4 w-4 mr-1" />
            )}
            <Folder className="h-4 w-4 mr-1" />
            <span>{node.name}</span>
          </div>
          {isExpanded && node.childIds && node.childIds.map((childId) => renderFileNode(childId, depth + 1))}
          {newFolderState.isCreatingFolder &&
            selectedFileNode?.id === node.id && (
              <div className="ml-4 px-2 py-1">
                <Input
                  variant="minimal"
                  ref={newFolderInputRef}
                  value={newFolderState.newFolderName}
                  onChange={(e) => newFolderState.setNewFolderName(e.target.value)}
                  onKeyDown={handleNewFolderKeyDown}
                  onBlur={newFolderState.cancelCreateFolder}
                  placeholder="New folder name"
                  className="w-full"
                />
              </div>
            )}
        </div>
      );
    } else if (node.type === "note") {
      return (
        <div
          key={node.id}
          className={cn(
            "flex items-center py-1 px-2 rounded-md cursor-pointer text-sm",
            isSelected
              ? "bg-accent text-accent-foreground"
              : "hover:bg-accent/50"
          )}
          style={{ marginLeft: depth * 16 }}
          onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            setActiveFileNodeId(node.id);
          }}
          onContextMenu={(e) => {
            e.preventDefault();
            e.stopPropagation();
            handleContextMenu(e, node);
          }}
        >
          <File className="h-4 w-4 mr-2" />
          <span className="truncate">{node.name}</span>
        </div>
      );
    }
    return null;
  };

  return (
    <ScrollArea className="h-[calc(100%-2.5rem)]">
      {newFolderState.error && (
        <div className="text-red-500 text-sm p-2">{newFolderState.error}</div>
      )}
      <div className="p-2">
        {isLoadingFolders ? (
          <div className="flex items-center justify-center h-20">
            <Loader className="h-6 w-6 animate-spin" />
          </div>
        ) : loadError ? (
          <div className="text-red-500 text-sm p-2">{loadError}</div>
        ) : directoryStructures.rootIds.length === 0 ? (
          <div className="text-sm text-muted-foreground p-2">
            No folders added yet.
          </div>
        ) : (
          directoryStructures.rootIds.map((rootId) => renderFileNode(rootId))
        )}
      </div>
    </ScrollArea>
  );
};

--- src/features/notes/components/NoteEditor.tsx ---

import React, { useState, useEffect, useCallback, useMemo } from "react";
import { useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import Highlight from "@tiptap/extension-highlight";
import TextAlign from "@tiptap/extension-text-align";
import Underline from "@tiptap/extension-underline";
import debounce from "lodash/debounce";
import { toast } from "@/shared/components/Toast";
import { cn } from "@/shared/utils";
import {
  Bold,
  Italic,
  Underline as UnderlineIcon,
  List,
  ListOrdered,
  AlignLeft,
  AlignCenter,
  AlignRight,
  Code,
  Quote,
  Highlighter,
  Pencil,
  Eye,
  Save,
  Loader2,
} from "lucide-react";
import { Input } from "@/shared/components/Input";
import { Button } from "@/shared/components/Button";
import { Toggle } from "@/shared/components/Toggle";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/shared/components/Tooltip";
import { Note } from "@/shared/types";
import { useNotesContext } from "../context/notesContext";
import { useDebouncedCallback } from "use-debounce";

interface NoteEditorProps {
  note: Note;
}

const NoteEditor: React.FC<NoteEditorProps> = ({ note }) => {
  const {
    activeNote,
    activeFileNode,
    saveNote,
    createEmbedding,
    getFileNodeFromPath,
    directoryStructures
  } = useNotesContext();

  const [localNote, setLocalNote] = useState(note);
  const [isEditing, setIsEditing] = useState(true);
  const [isSavingEmbedding, setIsSavingEmbedding] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isGeneratingEmbedding, setIsGeneratingEmbedding] = useState(false);
  const [indicatorStatus, setIndicatorStatus] = useState<
    "green" | "yellow" | "green"
  >("green");

  const editor = useEditor({
    extensions: [
      StarterKit,
      Highlight,
      TextAlign.configure({ types: ["heading", "paragraph"] }),
      Underline,
    ],
    content: note.content,
    editorProps: {
      attributes: {
        class: "prose dark:prose-invert max-w-none focus:outline-none",
      },
    },
  });

  useEffect(() => {
    if (editor && note.content !== editor.getHTML()) {
      editor.commands.setContent(note.content);
    }
    setLocalNote(note);
  }, [editor, note.content, note.id]);

  const debouncedSaveContent = useDebouncedCallback(
    async (updatedNote: Note) => {
      setIsSaving(true);
      try {
        await saveNote(updatedNote);
        setError(null);
        setIndicatorStatus("green");
      } catch (err) {
        setError("Failed to save note. Please try again.");
        toast("Error saving note", {
          description:
            "An error occurred while saving the note. Please try again.",
        });
      } finally {
        setIsSaving(false);
      }
    },
    5000,
    { leading: false, trailing: true }
  );

  const handleTitleChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      const newTitle = e.target.value;
      setLocalNote((prev) => ({ ...prev, title: newTitle }));
      setIndicatorStatus("yellow");
      saveNote({ ...localNote, title: newTitle }).catch((err) => {
        setError("Failed to save note title. Please try again.");
        toast("Error saving note title", {
          description:
            "An error occurred while saving the note title. Please try again.",
        });
      });
    },
    [localNote, saveNote]
  );

  const debouncedGenerateEmbedding = useDebouncedCallback(
    async () => {
      setIsGeneratingEmbedding(true);
      try {
        const success = await createEmbedding();
        if (success) {
          console.log("Embedding generated successfully");
        } else {
          console.error("Failed to generate embedding");
        }
      } catch (error) {
        console.error("Error generating embedding:", error);
      } finally {
        setIsGeneratingEmbedding(false);
      }
    },
    5000,
    { leading: false, trailing: true }
  );

  const handleContentChange = useCallback(() => {
    if (editor) {
      const content = editor.getHTML();
      setLocalNote((prev) => {
        if (prev.content !== content) {
          const updatedNote = { ...prev, content };
          setIndicatorStatus("yellow");
          debouncedSaveContent(updatedNote);
          debouncedGenerateEmbedding();
          return updatedNote;
        }
        return prev;
      });
    }
  }, [editor, debouncedSaveContent, debouncedGenerateEmbedding]);

  const handleSaveEmbedding = useCallback(async () => {
    if (editor) {
      setIsSavingEmbedding(true);
      console.log("attempting to save embedding");
      const success = await createEmbedding();
      if (success) {
        toast("Embedding saved successfully", {
          description:
            "The note's embedding has been updated for similarity search.",
        });
      } else {
        toast("Error saving embedding", {
          description:
            "An error occurred while saving the embedding. Please try again.",
        });
      }
      setIsSavingEmbedding(false);
    }
  }, [editor, localNote.id]);

  useEffect(() => {
    if (editor) {
      editor.on("update", handleContentChange);
      return () => {
        editor.off("update", handleContentChange);
      };
    }
  }, [editor, handleContentChange]);

  const applyFormat = useCallback(
    (format: string) => {
      if (editor) {
        switch (format) {
          case "bold":
          case "italic":
          case "underline":
            editor.chain().focus().toggleMark(format).run();
            break;
          case "bulletList":
            editor.chain().focus().toggleBulletList().run();
            break;
          case "orderedList":
            editor.chain().focus().toggleOrderedList().run();
            break;
          case "codeBlock":
            editor.chain().focus().toggleCodeBlock().run();
            break;
          case "blockquote":
            editor.chain().focus().toggleBlockquote().run();
            break;
          case "highlight":
            editor.chain().focus().toggleHighlight().run();
            break;
          case "alignLeft":
          case "alignCenter":
          case "alignRight":
            editor
              .chain()
              .focus()
              .setTextAlign(format.replace("align", "").toLowerCase())
              .run();
            break;
        }
      }
    },
    [editor]
  );

  const toolbarButtons = useMemo(
    () => [
      { icon: Bold, format: "bold" },
      { icon: Italic, format: "italic" },
      { icon: UnderlineIcon, format: "underline" },
      { icon: List, format: "bulletList" },
      { icon: ListOrdered, format: "orderedList" },
      { icon: AlignLeft, format: "alignLeft" },
      { icon: AlignCenter, format: "alignCenter" },
      { icon: AlignRight, format: "alignRight" },
      { icon: Code, format: "codeBlock" },
      { icon: Quote, format: "blockquote" },
      { icon: Highlighter, format: "highlight" },
    ],
    []
  );

  if (!editor) {
    return <div>Loading editor...</div>;
  }

  return (
    <div className="flex flex-col h-full bg-background text-foreground overflow-hidden p-4">
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center flex-grow mr-2">
          <Input
            type="text"
            value={localNote.title}
            onChange={handleTitleChange}
            placeholder="Note Title"
            className="text-2xl font-semibold border-none focus:ring-0 bg-background text-foreground flex-grow"
            aria-label="Note title"
          />
          {isSaving && <Loader2 className="h-4 w-4 animate-spin ml-2" />}
        </div>
        <div className="flex items-center space-x-2">
          {isGeneratingEmbedding && (
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="h-10 w-10 flex items-center justify-center">
                  <Loader2 className="h-4 w-4 animate-spin" />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Generating embedding...</p>
              </TooltipContent>
            </Tooltip>
          )}

          <Tooltip>
            <TooltipTrigger asChild>
              <div
                className={cn(
                  "w-2 h-2 rounded-full",
                  indicatorStatus === "green"
                    ? "bg-green-500"
                    : "bg-yellow-500 animate-pulse"
                )}
              />
            </TooltipTrigger>
            <TooltipContent>
              <p>
                {indicatorStatus === "green"
                  ? "Embedding up to date"
                  : "Embedding needs update"}
              </p>
            </TooltipContent>
          </Tooltip>

          <Tooltip>
            <TooltipTrigger asChild>
              <Toggle
                pressed={isEditing}
                onPressedChange={setIsEditing}
                aria-label="Toggle edit mode"
                className="h-10 w-10"
              >
                {isEditing ? (
                  <Pencil className="h-4 w-4" />
                ) : (
                  <Eye className="h-4 w-4" />
                )}
              </Toggle>
            </TooltipTrigger>
            <TooltipContent>
              <p>
                {isEditing
                  ? "Switch to reading mode"
                  : "Switch to editing mode"}
              </p>
            </TooltipContent>
          </Tooltip>
        </div>
      </div>
      <div className="flex-grow overflow-hidden">
        {isEditing ? (
          <div
            className={cn(
              "border rounded-md p-4 h-full bg-muted/50",
              "transition-shadow duration-200 overflow-hidden flex flex-col"
            )}
          >
            <div className="flex flex-wrap gap-2 mb-4">
              {toolbarButtons.map(({ icon: Icon, format }) => (
                <Button
                  key={format}
                  variant="ghost"
                  size="icon"
                  onClick={() => applyFormat(format)}
                  className={
                    editor.isActive(format)
                      ? "bg-accent text-accent-foreground"
                      : ""
                  }
                  aria-label={`Toggle ${format}`}
                >
                  <Icon className="h-4 w-4" />
                </Button>
              ))}
            </div>
            <div className="flex-grow overflow-auto">
              <EditorContent
                editor={editor}
                className="prose dark:prose-invert max-w-none focus:outline-none h-full"
              />
            </div>
          </div>
        ) : (
          <div
            className="prose dark:prose-invert max-w-none border rounded-md p-4 h-full bg-muted/50 overflow-auto"
            dangerouslySetInnerHTML={{ __html: editor.getHTML() }}
          />
        )}
      </div>
      {error && <div className="text-red-500 mt-2">{error}</div>}
    </div>
  );
};

export default NoteEditor;

--- src/features/notes/components/NoteExplorerHeader.tsx ---

import React from "react";
import { Button } from "@/shared/components/Button";
import { Pencil, FolderPlus, Plus } from "lucide-react";
import { useNotesContext } from "../context/notesContext";

interface NoteExplorerHeaderProps {
  onCreateNote: () => void;
  onCreateFolder: () => void;
}

export const NoteExplorerHeader: React.FC<NoteExplorerHeaderProps> = ({
  onCreateNote,
  onCreateFolder,
}) => {
  
  const {
    openDialogToMountDirpath
  } = useNotesContext();

  return (
    <div className="flex justify-between items-center p-2 h-10 border-b border-border">
      <span className="font-semibold text-sm">Files</span>
      <div className="flex">
        <Button
          variant="ghost"
          size="icon"
          className="h-8 w-8 mr-1"
          onClick={onCreateNote}
          title="New Note"
        >
          <Pencil className="h-4 w-4" />
        </Button>
        <Button
          variant="ghost"
          size="icon"
          className="h-8 w-8 mr-1"
          onClick={onCreateFolder}
          title="New Folder"
        >
          <FolderPlus className="h-4 w-4" />
        </Button>
        <Button
          variant="ghost"
          size="icon"
          className="h-8 w-8"
          onClick={openDialogToMountDirpath}
          title="Add Top-Level Folder"
        >
          <Plus className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
};
--- src/features/notes/components/RelatedNotes.tsx ---

import React, { useEffect } from "react";
import { Button } from "@/shared/components/Button";
import { ScrollArea } from "@/shared/components/ScrollArea";
import { cn } from "@/shared/utils";
import { Loader2, RefreshCw, Settings, Target, Zap } from "lucide-react";
import { toast } from "@/shared/components/Toast";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/shared/components/Tooltip";
import { SimilarNote } from "@/shared/types";
import { useResizableSidebar } from "@/shared/hooks/useResizableSidebar";
import { useNotesContext } from "../context/notesContext";

interface RelatedNotesProps {
  isOpen: boolean;
  onResize: (width: number) => void;
  onClose: () => void;
}

const RelatedNotes: React.FC<RelatedNotesProps> = ({
  isOpen,
  onResize,
  onClose,
}) => {
  const { width, sidebarRef, startResizing } = useResizableSidebar({
    minWidth: 100,
    maxWidth: 400,
    defaultWidth: 256,
    isOpen,
    onResize,
    onClose,
    side: "right",
  });

  const {
    findSimilarNotes,
    similarNotes,
    similarNotesIsLoading,
    activeNote,
    openNote,
  } = useNotesContext();

  const handleSettingsClick = () => {
    toast("Settings feature is not implemented yet", {
      description: "This feature will be available in a future update.",
    });
  };

  useEffect(() => {
    if (isOpen && activeNote) {
      findSimilarNotes();
    }
  }, [isOpen, activeNote, findSimilarNotes]);

  return (
    <div
      ref={sidebarRef}
      className={cn(
        "fixed top-12 right-0 h-[calc(100vh-3rem)] bg-background border-l border-border transition-all duration-300 z-10 overflow-hidden",
        isOpen ? `w-[${width}px]` : "w-0"
      )}
      style={{ width: isOpen ? width : 0 }}
    >
      <div className="flex justify-between items-center p-2 h-10 border-b border-border">
        <span className="font-semibold text-sm">Related Notes</span>
        <Button
          variant="ghost"
          size="icon"
          onClick={findSimilarNotes}
          className="h-6 w-6"
          title="Refresh similar notes"
        >
          <RefreshCw className="h-4 w-4" />
        </Button>
      </div>
      <ScrollArea className="h-[calc(100%-5rem)]">
        <div className="p-4">
          {similarNotesIsLoading ? (
            <div className="flex items-center justify-center h-20">
              <Loader2 className="h-6 w-6 animate-spin" />
            </div>
          ) : (
            <>
              {similarNotes.length > 0 ? (
                <ul>
                  {similarNotes.map((note) => (
                    <li
                      key={note.id}
                      className="cursor-pointer hover:bg-accent/10 p-2 rounded mb-2"
                      onClick={async () => {
                        openNote(note);
                      }}
                    >
                      <div className="flex justify-between items-center mb-1">
                        <h3 className="font-semibold truncate mr-2">
                          {note.title}
                        </h3>
                        <TooltipProvider>
                          <Tooltip>
                            <TooltipTrigger>
                              <span
                                className={`text-sm font-medium flex items-center ${getScoreColor(
                                  note.score
                                )}`}
                              >
                                <Target className="h-3 w-3 mr-1 opacity-60" />
                                {note.score.toFixed(2)}
                              </span>
                            </TooltipTrigger>
                            <TooltipContent>
                              <p>Similarity score: {note.score.toFixed(2)}</p>
                            </TooltipContent>
                          </Tooltip>
                        </TooltipProvider>
                      </div>
                      <div
                        className="text-sm text-muted-foreground prose dark:prose-invert max-w-none line-clamp-3"
                        dangerouslySetInnerHTML={{ __html: note.content }}
                      />
                    </li>
                  ))}
                </ul>
              ) : (
                <p>No similar notes found</p>
              )}
            </>
          )}
        </div>
      </ScrollArea>
      <div className="absolute bottom-2 right-2">
        <Button
          variant="ghost"
          size="icon"
          className="h-8 w-8"
          onClick={handleSettingsClick}
          title="Settings"
        >
          <Settings className="h-4 w-4" />
        </Button>
      </div>
      <div
        onMouseDown={startResizing}
        className="absolute top-0 left-0 w-1 h-full cursor-ew-resize hover:bg-accent/50"
      />
    </div>
  );
};

const getScoreColor = (score: number): string => {
  if (score >= 0.9) return "text-emerald-600 dark:text-emerald-400";
  if (score >= 0.8) return "text-green-600 dark:text-green-400";
  if (score >= 0.7) return "text-yellow-600 dark:text-yellow-400";
  if (score >= 0.6) return "text-orange-600 dark:text-orange-400";
  return "text-red-600 dark:text-red-400";
};

export default RelatedNotes;

--- src/features/notes/components/BottomPane.tsx ---

import React from "react";
import { cn } from "@/shared/utils";
import { useResizablePane } from "@/shared/hooks/useResizablePane";
import { ScrollArea } from "@/shared/components/ScrollArea";
import { Button } from "@/shared/components/Button";
import { Settings } from "lucide-react";
import { toast } from "@/shared/components/Toast";

interface BottomPaneProps {
  isOpen: boolean;
  onResize: (height: number) => void;
  onClose: () => void;
}

const BottomPane: React.FC<BottomPaneProps> = ({
  isOpen,
  onResize,
  onClose,
}) => {
  const { height, paneRef, startResizing } = useResizablePane({
    minHeight: 100,
    maxHeight: 400,
    defaultHeight: 256,
    isOpen,
    onResize,
    onClose,
  });

  return (
    <div
      ref={paneRef}
      className={cn(
        "fixed bottom-0 left-0 right-0 bg-background border-t border-border transition-all duration-300 z-10 overflow-hidden",
        isOpen ? `h-[${height}px]` : "h-0"
      )}
      style={{ height: isOpen ? height : 0 }}
    >
      <div className="flex justify-between items-center p-2 h-10 border-b border-border">
        <span className="font-semibold text-sm">Bottom Pane</span>
        <Button
          variant="ghost"
          size="icon"
          className="h-6 w-6"
          onClick={() => toast("Settings feature is not implemented yet")}
          title="Settings"
        >
          <Settings className="h-4 w-4" />
        </Button>
      </div>
      <ScrollArea className="h-[calc(100%-2.5rem)]">
        <div className="p-4">
          <p>This is the content of the bottom pane.</p>
        </div>
      </ScrollArea>
      <div
        onMouseDown={startResizing}
        className="absolute top-0 left-0 w-full h-1 cursor-ns-resize hover:bg-accent/50"
        style={{ top: "-1px" }}
      />
    </div>
  );
};

export default BottomPane;

--- src/features/notes/components/NoteExplorerContextMenu.tsx ---

// src/features/notes/components/NoteExplorerContextMenu.tsx

import React from "react";
import ContextMenu from "@/shared/components/ContextMenu/ContextMenu";
import ContextMenuItem from "@/shared/components/ContextMenu/ContextMenuItem";
import {
  FilePlus,
  FolderPlus,
  Trash2,
  Copy,
  Folder,
  Pencil,
} from "lucide-react";
import { FileNode } from "@/shared/types";
import { useNotesContext } from "../context/notesContext";

interface NoteExplorerContextMenuProps {
  contextMenu: {
    x: number;
    y: number;
    fileNode: FileNode;
  } | null;
  onClose: () => void;
  onDelete: () => void;
  onCopyFilePath: (fileNode: FileNode) => void;
  onOpenNoteInNewTab: (fileNode: FileNode) => void;
}

const NoteExplorerContextMenu: React.FC<NoteExplorerContextMenuProps> = ({
  contextMenu,
  onClose,
  onDelete,
  onCopyFilePath,
  onOpenNoteInNewTab,
}) => {
  const { handleCreateFolder, createNote } = useNotesContext();
  if (!contextMenu) return null;
  const { x, y, fileNode } = contextMenu;

  return (
    <ContextMenu x={x} y={y} onClose={onClose}>
      {(fileNode.type === "directory") && (
        <>
          <ContextMenuItem
            icon={FilePlus}
            label="New File"
            onClick={() => {
              createNote(fileNode.fullPath);
              onClose();
            }}
          />
          <ContextMenuItem
            icon={FolderPlus}
            label="New Folder"
            onClick={() => {
              handleCreateFolder(fileNode);
              onClose();
            }}
          />
        </>
      )}
      <ContextMenuItem
        icon={Trash2}
        label="Delete"
        onClick={() => {
          onDelete();
          onClose();
        }}
        className="text-destructive"
      />
      {fileNode.type === "note" && (
        <>
          <ContextMenuItem
            icon={Copy}
            label="Copy ID"
            onClick={() => {
              navigator.clipboard.writeText(fileNode.noteMetadata?.id || "");
              onClose();
            }}
          />
          <ContextMenuItem
            icon={Folder}
            label="Copy File Path"
            onClick={() => {
              onCopyFilePath(fileNode);
              onClose();
            }}
          />
          <ContextMenuItem
            icon={Pencil}
            label="Open in New Tab"
            onClick={() => {
              onOpenNoteInNewTab(fileNode);
              onClose();
            }}
          />
        </>
      )}
    </ContextMenu>
  );
};

export default NoteExplorerContextMenu;

--- src/features/notes/hooks/useNoteExplorerContextMenu.tsx ---

// src/features/notes/hooks/useNoteExplorerContextMenu.tsx

import { FileNode } from "@/shared/types";
import { useState, useCallback, useEffect } from "react";

interface ContextMenuState {
  x: number;
  y: number;
  fileNode: FileNode;
}

export const useNoteExplorerContextMenu = () => {
  const [contextMenu, setContextMenu] = useState<ContextMenuState | null>(null);

  const handleContextMenu = useCallback(
    (
      e: React.MouseEvent,
      fileNode: FileNode
    ) => {
      e.preventDefault();
      e.stopPropagation();
      setContextMenu({
        x: e.clientX,
        y: e.clientY,
        fileNode
      });
    },
    []
  );

  const closeContextMenu = useCallback(() => {
    setContextMenu(null);
  }, []);

  useEffect(() => {
    const handleGlobalClick = () => {
      closeContextMenu();
    };

    if (contextMenu) {
      document.addEventListener("click", handleGlobalClick);
    }

    return () => {
      document.removeEventListener("click", handleGlobalClick);
    };
  }, [contextMenu, closeContextMenu]);

  return { contextMenu, handleContextMenu, closeContextMenu };
};

--- src/features/notes/hooks/useNotes.ts ---

// src/features/notes/hooks/useNotes.ts

import { v4 as uuidv4 } from "uuid";
import { useState, useEffect, useCallback, useMemo } from "react";
import {
  Note,
  FileNode,
  DirectoryStructures,
  SimilarNote,
} from "@/shared/types";
import { toast } from "@/shared/components/Toast";

export const useNotes = () => {
  const [notes, setNotes] = useState<Note[]>([]);
  const [directoryStructures, setDirectoryStructures] = useState<DirectoryStructures>({
    rootIds: [],
    nodes: {},
  });
  const [activeFileNodeId, setActiveFileNodeId] = useState<string | null>(null);
  const [activeNote, setActiveNote] = useState<Note | null>(null);
  const [similarNotes, setSimilarNotes] = useState<SimilarNote[]>([]);
  const [similarNotesIsLoading, setSimilarNotesIsLoading] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState(true);

  // File System Explorer State
  const [expandedDirs, setExpandedDirs] = useState<Set<string>>(new Set());
  const [currentPath, setCurrentPath] = useState<string>("");
  const [isCreatingFolder, setIsCreatingFolder] = useState(false);
  const [newFolderName, setNewFolderName] = useState("");
  const [error, setError] = useState<string | null>(null);

  // Mounted Folder States
  const [mountedDirPaths, setMountedDirPaths] = useState<string[]>([]);
  const [isLoadingMountedDirPaths, setIsLoadingMountedDirPaths] = useState(false);
  const [mountedDirPathsLoadError, setMountedDirPathsLoadError] = useState<string | null>(null);

  useEffect(() => {
    if (activeFileNodeId) {
      const fileNode = directoryStructures.nodes[activeFileNodeId];
      if (fileNode) {
        setActiveFileNode(fileNode);
      } else {
        console.error("Could not find file node for id", activeFileNodeId);
      }
    }
  }, [activeFileNodeId, directoryStructures]);

  // Compute activeFileNode
  const activeFileNode = useMemo(() => {
    return activeFileNodeId ? directoryStructures.nodes[activeFileNodeId] : null;
  }, [activeFileNodeId, directoryStructures]);

  // Update functions to use activeFileNodeId
  const setActiveFileNode = useCallback((node: FileNode) => {
    setActiveFileNodeId(node.id);
  }, []);
  

  // Load the active note based on the active file node
  useEffect(() => {
    let isCurrent = true;

    const loadActiveNote = async () => {
      if (activeFileNode?.type === "note") {
        try {
          const loadedNote = await window.electron.loadNote(activeFileNode.fullPath);
          if (isCurrent) {
            setActiveNote(loadedNote);
          }
        } catch (err) {
          console.error("Failed to load note:", err);
          if (isCurrent) {
            setActiveNote(null);
          }
        }
      } else {
        if (isCurrent) {
          setActiveNote(null);
        }
      }
    };
    loadActiveNote();

    return () => {
      isCurrent = false;
    };
  }, [activeFileNode]);

  const loadNotes = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const topLevelDirPaths = await window.electron.getTopLevelFolders();
      const dirStructuresPromises = topLevelDirPaths.map(async (dirPath) => {
        try {
          const dirStructure = await window.electron.getDirectoryStructure(dirPath);
          return dirStructure;
        } catch (err) {
          console.error(`Failed to load directory structure for ${dirPath}:`, err);
          setError(err);
          return null;
        }
      });
      const dirStructures = await Promise.all(dirStructuresPromises);
      const newDirectoryStructures: DirectoryStructures = {
        rootIds: [],
        nodes: {},
      };
      dirStructures.forEach((dirStructure) => {
        if (dirStructure) {
          buildDirectoryStructures(dirStructure, null, newDirectoryStructures);
        }
      });
      setDirectoryStructures(newDirectoryStructures);
    } catch (err) {
      console.error("Failed to load top-level directories:", err);
      setError(err)
    } finally {
      setIsLoading(false);
    }
  }, []);

  const buildDirectoryStructures = (
    dirStructure: any,
    parentId: string | null,
    directoryStructures: DirectoryStructures
  ) => {
    const id = uuidv4();
    const fileNode: FileNode = {
      id,
      name: dirStructure.name,
      type: dirStructure.type,
      parentId,
      fullPath: dirStructure.fullPath,
      childIds: [],
    };
    if (dirStructure.type === "note" && dirStructure.noteMetadata) {
      fileNode.noteMetadata = dirStructure.noteMetadata;
    }
    directoryStructures.nodes[id] = fileNode;
    if (!parentId) {
      directoryStructures.rootIds.push(id);
    } else {
      const parent = directoryStructures.nodes[parentId];
      if (parent) {
        parent.childIds = parent.childIds || [];
        parent.childIds.push(id);
      }
    }
    if (dirStructure.children) {
      dirStructure.children.forEach((child: any) => {
        buildDirectoryStructures(child, id, directoryStructures);
      });
    }
  };

  useEffect(() => {
    loadNotes();
  }, [loadNotes]);

  const createNote = useCallback(
    async (dirPath: string) => {
      const timestamp = new Date().toISOString();
      const newNote: Note = {
        id: uuidv4(),
        title: "Untitled Note",
        content: "",
        createdAt: timestamp,
        updatedAt: timestamp,
      };
      try {
        const savedNotePath = await window.electron.saveNote(newNote, dirPath);
        await loadNotes();
        const newFileNodeId = findFileNodeIdByFullPath(savedNotePath);
        if (newFileNodeId) {
          setActiveFileNodeId(newFileNodeId);
        }
      } catch (error) {
        console.error("Error creating note:", error);
      }
    },
    [loadNotes, directoryStructures]
  );

  const saveNote = useCallback(
    async (updatedNote: Note) => {
      if (!activeFileNode || activeFileNode.type !== "note") {
        console.error("No active note file node");
        return;
      }
      try {
        const dirPath = activeFileNode.fullPath.substring(
          0,
          activeFileNode.fullPath.lastIndexOf("/")
        );
        await window.electron.saveNote(updatedNote, dirPath);
  
        // Correctly update the directoryStructures
        setDirectoryStructures((prevStructures) => {
          const updatedNodes = { ...prevStructures.nodes }; // Clone nodes object
          const nodeId = activeFileNode.id;
          const node = updatedNodes[nodeId];
          if (node) {
            updatedNodes[nodeId] = {
              ...node, // Create a new node object
              name: updatedNote.title,
              noteMetadata: {
                ...node.noteMetadata,
                title: updatedNote.title,
              },
            };
          }
          return {
            ...prevStructures,
            nodes: updatedNodes, // Use the updated nodes object
          };
        });
  
        // No need to update activeFileNode explicitly; it will update via useMemo
      } catch (error) {
        console.error("Error saving note:", error);
        toast.error("Failed to save note. Please try again.");
      }
    },
    [activeFileNode]
  );

  const deleteFileNode = useCallback(
    async (fileNode: FileNode) => {
      try {
        await window.electron.deleteFileNode(fileNode.type, fileNode.fullPath);
        const topLevelFolderPaths = await window.electron.getTopLevelFolders();
        if (topLevelFolderPaths.includes(fileNode.fullPath)) {
          await window.electron.removeTopLevelFolder(fileNode.fullPath);
        }
        await loadNotes();
      } catch (error) {
        console.error("Error deleting file node:", error);
      }
    },
    [loadNotes]
  );

  const findSimilarNotes = useCallback(async () => {
    if (!activeNote) {
      console.error('no active note')
      setSimilarNotes([]);
      setSimilarNotesIsLoading(false);
      return;
    }
    setSimilarNotesIsLoading(true);
    try {
      const similarNotes = await window.electron.findSimilarNotes(
        activeNote.content,
        directoryStructures
      );
      setSimilarNotes(
        similarNotes.filter(
          (note: SimilarNote) => note.id !== activeNote.id && note.score >= 0.6
        )
      );
    } catch (error) {
      console.error("Error finding similar notes:", error);
      setSimilarNotes([]);
    } finally {
      setSimilarNotesIsLoading(false);
    }
  }, [activeNote?.content, activeNote?.id, directoryStructures]);

  const toggleDirectory = useCallback((fileNode: FileNode) => {
    setExpandedDirs((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(fileNode.id)) {
        newSet.delete(fileNode.id);
      } else {
        newSet.add(fileNode.id);
      }
      return newSet;
    });
  }, []);

  const handleCreateFolder = useCallback((fileNode: FileNode) => {
    setActiveFileNode(fileNode);
    setIsCreatingFolder(true);
    setNewFolderName("");
    setError(null);
  }, []);

  const confirmCreateFolder = useCallback(async () => {
    if (!newFolderName.trim()) {
      setError("Folder name cannot be empty");
      return;
    }

    const invalidChars = /[<>:"/\\|?*\p{C}]/u;
    if (invalidChars.test(newFolderName)) {
      setError("Folder name contains invalid characters");
      return;
    }

    if (!activeFileNode) {
      setError("No active directory selected");
      return;
    }

    try {
      await window.electron.createDirectory(
        `${activeFileNode.fullPath}/${newFolderName.trim()}`
      );
      setIsCreatingFolder(false);
      setNewFolderName("");
      setError(null);
      await loadNotes();
    } catch (err) {
      setError(`Failed to create folder: ${err instanceof Error ? err.message : String(err)}`);
    }
  }, [activeFileNode, newFolderName, loadNotes]);

  const cancelCreateFolder = useCallback(() => {
    setIsCreatingFolder(false);
    setNewFolderName("");
    setError(null);
  }, []);

  const loadMountedDirPaths = useCallback(async () => {
    setIsLoadingMountedDirPaths(true);
    setMountedDirPathsLoadError(null);
    try {
      const dirPaths = await window.electron.getTopLevelFolders();
      setMountedDirPaths(dirPaths);
    } catch (error) {
      setMountedDirPathsLoadError("Failed to load top-level folders");
      console.error(error);
    } finally {
      setIsLoadingMountedDirPaths(false);
    }
  }, []);

  useEffect(() => {
    loadMountedDirPaths();
  }, [loadMountedDirPaths]);

  const openDialogToMountDirpath = useCallback(async () => {
    const result = await window.electron.openFolderDialog();
    if (result) {
      await window.electron.addTopLevelFolder(result);
      await loadMountedDirPaths();
      await loadNotes();
    }
  }, [loadMountedDirPaths, loadNotes]);

  const createEmbedding = useCallback(async (): Promise<boolean> => {
    if (activeFileNode?.type === "note" && activeNote) {
      try {
        await window.electron.generateNoteEmbeddings(activeNote, activeFileNode);
        return true;
      } catch (error) {
        console.error(`Failed generating note embedding:`, error);
        return false;
      }
    } else {
      console.error(`Embedding creation triggered for invalid file node type`);
      return false;
    }
  }, [activeFileNode, activeNote]);

  const getFileNodeFromNote = useCallback(
    (note: Note): FileNode | null => {
      const fileNode = Object.values(directoryStructures.nodes).find(
        (node) => node.type === "note" && node.noteMetadata?.id === note.id
      );
      return fileNode || null;
    },
    [directoryStructures]
  );

  const getFileNodeFromPath = useCallback(
    (fullPath: string): FileNode | null => {
      const fileNode = Object.values(directoryStructures.nodes).find(
        (node) => node.fullPath === fullPath
      );
      return fileNode || null;
    },
    [directoryStructures]
  );

  const findFileNodeIdByFullPath = useCallback(
    (fullPath: string): string | null => {
      const fileNode = Object.values(directoryStructures.nodes).find(
        (node) => node.fullPath === fullPath
      );
      return fileNode ? fileNode.id : null;
    },
    [directoryStructures]
  );

  const openNote = useCallback(
    (note: Note) => {
      const fileNode = getFileNodeFromNote(note);
      if (fileNode) {
        setActiveFileNodeId(fileNode.id);
      } else {
        console.error("Could not find file node for note", note);
      }
    },
    [getFileNodeFromNote]
  );

  return {
    notes,
    directoryStructures,
    similarNotes,
    isLoading,
    createNote,
    saveNote,
    findSimilarNotes,
    loadNotes,
    activeFileNodeId,
    setActiveFileNodeId,
    activeNote,
    activeFileNode,
    setActiveFileNode,
    deleteFileNode,
    expandedDirs,
    toggleDirectory,
    currentPath,
    setCurrentPath,
    handleCreateFolder,
    newFolderState: {
      isCreatingFolder,
      newFolderName,
      setNewFolderName,
      confirmCreateFolder,
      cancelCreateFolder,
      error,
    },
    openDialogToMountDirpath,
    createEmbedding,
    getFileNodeFromNote,
    similarNotesIsLoading,
    getFileNodeFromPath,
    openNote,
    error
  };
};

--- src/features/theme/index.tsx ---

export { ThemeProvider } from './context/ThemeContext'
export { ThemeToggle } from './components/ThemeToggle'
export { useTheme } from './hooks/useTheme'
export type { Theme } from './config/themeConfig'
--- src/features/theme/context/ThemeContext.tsx ---

import React, { createContext, useContext, useEffect, useState } from 'react'
import { Theme } from '../config/themeConfig'
import { applyTheme, getInitialTheme } from '../utils/themeUtils'

type ThemeContextType = {
  theme: Theme
  setTheme: (theme: Theme) => void
}

export const ThemeContext = createContext<ThemeContextType | undefined>(undefined)

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>(getInitialTheme)

  useEffect(() => {
    applyTheme(theme)
  }, [theme])

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}
--- src/features/theme/config/themeConfig.ts ---

export const THEME_STORAGE_KEY = 'theme'
export const DEFAULT_THEME = 'light'
export const AVAILABLE_THEMES = ['light', 'dark'] as const

export type Theme = typeof AVAILABLE_THEMES[number]
--- src/features/theme/utils/themeUtils.ts ---

import { Theme, THEME_STORAGE_KEY, DEFAULT_THEME } from '../config/themeConfig'

export function applyTheme(theme: Theme) {
  const root = window.document.documentElement
  root.classList.remove('light', 'dark')
  root.classList.add(theme)
  localStorage.setItem(THEME_STORAGE_KEY, theme)
}

export function getInitialTheme(): Theme {
  if (typeof window !== 'undefined') {
    return localStorage.getItem(THEME_STORAGE_KEY) as Theme || DEFAULT_THEME
  }
  return DEFAULT_THEME
}
--- src/features/theme/components/ThemeToggle.tsx ---

import { Moon, Sun } from "lucide-react"
import { Button } from "@/shared/components/Button"
import { useTheme } from "../hooks/useTheme"

export function ThemeToggle() {
  const { setTheme, theme } = useTheme()

  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
    >
      <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
      <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  )
}
--- src/features/theme/hooks/useTheme.ts ---

import { useContext } from 'react'
import { ThemeContext } from '../context/ThemeContext'

export function useTheme() {
  const context = useContext(ThemeContext)
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider')
  }
  return context
}
--- src/features/feed/index.tsx ---

import Feed from './Feed';

export {
  Feed
};
--- src/features/feed/Feed.tsx ---

import { Card } from "@/shared/components/Card";

const Feed = () => (
  <div className="container mx-auto p-4 mt-2">
    <h2 className="text-2xl font-bold mb-4">Welcome</h2>
    <Card className="p-6 mb-6">
      <h3 className="text-xl font-semibold mb-3">About</h3>
      <p className="mb-4">
        This tool is focused on providing great UX for information management.
      </p>
    </Card>

    <Card className="p-6 mb-6">
      <h3 className="text-xl font-semibold mb-3">
        Getting Started
      </h3>
      <p className="mb-4">
        To get started, please follow these steps:
      </p>
      <ol className="list-decimal list-inside">
        <li>Go to the Settings page (in the top right)</li>
        <li>Enter your OpenAI API key in the designated field</li>
      </ol>
      <p className="mt-4">
        Currently, the OpenAI API key is only used to calculate vector
        embeddings of content, which are then ONLY stored on your local file
        system and possible by OpenAI. No guarantees may be made about how
        OpenAI handles the data on their end.
      </p>
    </Card>

    <Card className="p-6">
      <h3 className="text-xl font-semibold mb-3">
        Feature Status
      </h3>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <h4 className="font-bold mb-2">
            Functional Features:
          </h4>
          <ul className="list-disc list-inside">
            <li>Create, edit, and delete notes</li>
            <li>Light and dark theme</li>
            <li>Auto-save functionality</li>
            <li>Sidebar for quick note navigation</li>
          </ul>
        </div>
        <div>
          <h4 className="font-bold mb-2">In Progress:</h4>
          <ul className="list-disc list-inside">
            <li>Markdown editing (partially implemented)</li>
            <li>Automatic embedding process</li>
            <li>Feed implementation</li>
            <li>File tab implementation</li>
            <li>Infinitely nestable data structures</li>
            <li>AI-first search and chat functionality</li>
            <li>Customizable background agents</li>
          </ul>
        </div>
      </div>
    </Card>
  </div>
);

export default Feed;
--- src/index.css ---

@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 0%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 0%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 0%;
    --primary: 142 76% 36%;
    --primary-foreground: 0 0% 100%;
    --secondary: 210 20% 96%;
    --secondary-foreground: 0 0% 0%;
    --muted: 210 20% 96%;
    --muted-foreground: 215 16% 47%;
    --accent: 210 20% 96%;
    --accent-foreground: 0 0% 0%;
    --destructive: 0 84% 60%;
    --destructive-foreground: 0 0% 100%;
    --border: 220 13% 91%;
    --input: 220 13% 91%;
    --ring: 142 76% 36%;
    --radius: 0.5rem;
    --gradient-start: 142 76% 33%;
    --gradient-end: 142 76% 39%;
  }
 
  .dark {
    --background: 220 6% 10%;
    --foreground: 210 6% 93%;
    --card: 220 6% 13%;
    --card-foreground: 210 6% 93%;
    --popover: 220 6% 13%;
    --popover-foreground: 210 6% 93%;
    --primary: 142 76% 45%;
    --primary-foreground: 0 0% 100%;
    --secondary: 220 6% 16%;
    --secondary-foreground: 210 6% 93%;
    --muted: 220 6% 20%;
    --muted-foreground: 217 8% 64%;
    --accent: 220 6% 20%;
    --accent-foreground: 210 6% 93%;
    --destructive: 0 84% 60%;
    --destructive-foreground: 0 0% 100%;
    --border: 220 6% 18%;
    --input: 220 6% 18%;
    --ring: 142 76% 45%;
    --gradient-start: 142 76% 42%;
    --gradient-end: 142 76% 48%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@layer utilities {
  .bg-gradient-primary {
    background: linear-gradient(135deg, hsl(var(--gradient-start)), hsl(var(--gradient-end)));
  }
}

/* For making the navbar draggable */
.drag-handle {
  -webkit-app-region: drag;
}

.drag-handle button,
.drag-handle a {
  -webkit-app-region: no-drag;
}
--- src/shared/types/index.ts ---

// src/shared/types/index.ts

import OpenAI from "openai";

export interface NoteMetadata {
  id: string;
  title: string;
  createdAt?: string;
  updatedAt?: string;
  tags?: string[];
}

export interface NoteContent {
  content?: string;
}

export interface Note extends NoteMetadata, NoteContent {}

export interface FileNode {
  id: string;
  name: string;
  type: 'directory' | 'note';
  parentId: string | null;
  noteMetadata?: NoteMetadata;
  fullPath: string;
  childIds?: string[];
}

export interface FileNodeMap {
  [id: string]: FileNode;
}

export interface DirectoryStructures {
  rootIds: string[];
  nodes: FileNodeMap;
}

export interface SimilarNote extends Note {
  score: number;
}

export interface TabInfo {
  id: string;
  title: string;
}

export type Embedding = OpenAI.Embeddings.CreateEmbeddingResponse;

export interface Config {
  openaiApiKey?: string;
}

export interface DirectoryEntry {
  name: string;
  type: "directory" | "note";
  noteMetadata?: NoteMetadata;
  fullPath: string;
  children?: DirectoryEntry[];
}
--- src/shared/utils/index.ts ---

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function getFolderName(path: string): string {
  return path.split('/').pop() || path
}
--- src/shared/components/Tabs/index.tsx ---

export { default as Tabs } from './Tabs';
export { default as TabsList } from './TabsList';
export { default as TabsTrigger } from './TabsTrigger';
export { default as TabsContent } from './TabsContent';
export { default as CustomTabBar } from './CustomTabBar';
--- src/shared/components/Tabs/Tabs.tsx ---

import * as TabsPrimitive from "@radix-ui/react-tabs";

const Tabs = TabsPrimitive.Root;

export default Tabs;
--- src/shared/components/Tabs/TabsContent.tsx ---

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/shared/utils";

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background",
      "focus-visible:outline-none focus-visible:ring-2",
      "focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
));
TabsContent.displayName = "TabsContent";

export default TabsContent;
--- src/shared/components/Tabs/TabsTrigger.tsx ---

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/shared/utils";

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap",
      "rounded-sm px-3 py-1.5 text-sm font-medium",
      "ring-offset-background transition-all",
      "focus-visible:outline-none focus-visible:ring-2",
      "focus-visible:ring-ring focus-visible:ring-offset-2",
      "disabled:pointer-events-none disabled:opacity-50",
      "data-[state=active]:bg-background data-[state=active]:text-foreground",
      "data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
));
TabsTrigger.displayName = "TabsTrigger";

export default TabsTrigger;
--- src/shared/components/Tabs/TabsList.tsx ---

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/shared/utils";

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md",
      "bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
));
TabsList.displayName = "TabsList";

export default TabsList;
--- src/shared/components/Tabs/CustomTabBar.tsx ---

import React from 'react';
import { X } from 'lucide-react';
import { Button } from '@/shared/components/Button';
import { cn } from '@/shared/utils';

interface Tab {
  id: string;
  title: string;
}

interface CustomTabBarProps {
  tabs: Tab[];
  activeTab: string;
  onTabClick: (id: string) => void;
  onTabClose: (id: string) => void;
  onTabDragStart: (id: string, e: React.DragEvent) => void;
}

const CustomTabBar: React.FC<CustomTabBarProps> = ({
  tabs,
  activeTab,
  onTabClick,
  onTabClose,
  onTabDragStart,
}) => {
  return (
    <div className="flex bg-background border-b border-border overflow-x-auto mt-2">
      {tabs.map((tab) => (
        <div
          key={tab.id}
          className={cn(
            "flex items-center px-3 py-2 border-r border-border cursor-pointer group",
            activeTab === tab.id
              ? "bg-accent text-accent-foreground"
              : "hover:bg-accent/50"
          )}
          onClick={() => onTabClick(tab.id)}
          draggable
          onDragStart={(e) => onTabDragStart(tab.id, e)}
        >
          <span className="mr-2 truncate max-w-[120px]">{tab.title}</span>
          <Button
            variant="ghost"
            size="icon"
            className="h-4 w-4 ml-2 opacity-0 group-hover:opacity-100 transition-opacity"
            onClick={(e) => {
              e.stopPropagation();
              onTabClose(tab.id);
            }}
          >
            <X className="h-3 w-3" />
          </Button>
        </div>
      ))}
    </div>
  );
};

export default CustomTabBar;
--- src/shared/components/Card.tsx ---

import React from "react";

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: "default" | "primary";
}

export const Card: React.FC<CardProps> = ({
  children,
  className,
  variant = "default",
  ...props
}) => {
  const baseClasses = "rounded-2xl p-4 transition-shadow duration-200";
  const variantClasses =
    variant === "primary"
      ? "bg-gradient-primary text-primary-foreground"
      : "bg-secondary text-secondary-foreground";

  return (
    <div
      className={`${baseClasses} ${variantClasses} hover:shadow-md ${
        className || ""
      }`}
      {...props}
    >
      {children}
    </div>
  );
};

--- src/shared/components/ContextMenu/ContextMenu.tsx ---

import React from 'react';
import { cn } from '@/shared/utils';

interface ContextMenuProps {
  x: number;
  y: number;
  onClose: () => void;
  children: React.ReactNode;
}

const ContextMenu: React.FC<ContextMenuProps> = ({ x, y, onClose, children }) => {
  return (
    <div
      className={cn(
        "absolute z-50 min-w-[200px] bg-popover text-popover-foreground",
        "rounded-md shadow-md overflow-hidden"
      )}
      style={{ top: y, left: x }}
    >
      {children}
    </div>
  );
};

export default ContextMenu;
--- src/shared/components/ContextMenu/ContextMenuItem.tsx ---

import React from 'react';
import { Button } from '@/shared/components/Button';
import { LucideIcon } from 'lucide-react';

interface ContextMenuItemProps {
  icon?: LucideIcon;
  label: string;
  onClick: () => void;
  className?: string;
}

const ContextMenuItem: React.FC<ContextMenuItemProps> = ({ icon: Icon, label, onClick, className }) => {
  return (
    <Button
      variant="ghost"
      className={`w-full justify-start px-2 py-1.5 text-sm ${className}`}
      onClick={onClick}
    >
      {Icon && <Icon className="mr-2 h-4 w-4" />}
      {label}
    </Button>
  );
};

export default ContextMenuItem;
--- src/shared/components/Tooltip.tsx ---

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { cn } from "@/shared/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      `z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5
       text-sm text-popover-foreground shadow-md animate-in fade-in-0
       zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0
       data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2
       data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2
       data-[side=top]:slide-in-from-bottom-2
      `,
      className
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

--- src/shared/components/ScrollArea.tsx ---

import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";
import { cn } from "@/shared/utils";

// ScrollArea: A customizable scrollable area component
const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root> & {
    hideScrollbar?: boolean;
  }
>(({ className, children, hideScrollbar = false, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    {!hideScrollbar && <ScrollBar />}
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = "ScrollArea";

// ScrollBar: A customizable scrollbar component
const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = "ScrollBar";

export { ScrollArea, ScrollBar };

--- src/shared/components/Button.tsx ---

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/shared/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  (
    { className, variant, size, asChild = false, ...props },
    ref
  ): JSX.Element => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = "Button";

export { Button, buttonVariants };

--- src/shared/components/Toggle.tsx ---

import * as React from "react";
import * as TogglePrimitive from "@radix-ui/react-toggle";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/shared/utils";

const toggleVariants = cva(
  `inline-flex items-center justify-center rounded-md text-sm font-medium
  ring-offset-background transition-colors hover:bg-muted
  hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2
  focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none
  disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground`,
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: `border border-input bg-transparent hover:bg-accent
                  hover:text-accent-foreground`,
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };

--- src/shared/components/Toast.tsx ---

import { Toaster as SonnerToaster, toast as sonnerToast } from 'sonner';

export const Toaster = SonnerToaster;

export const toast = sonnerToast;
--- src/shared/components/input.tsx ---

import * as React from "react";
import { cn } from "@/shared/utils";
import { InputHTMLAttributes } from "react";

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  variant?: 'default' | 'minimal';
}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, variant = 'default', ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          // Default styles
          `flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm
          ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium
          placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-0
          disabled:cursor-not-allowed disabled:opacity-50`,
          // Minimal variant styles
          variant === 'minimal' && `h-auto w-auto border-none bg-transparent p-0`,
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = "Input";

export { Input };
--- src/shared/hooks/useResizablePane.ts ---

import { useState, useCallback, useRef, useEffect } from 'react';

interface UseResizablePaneProps {
  minHeight: number;
  maxHeight: number;
  defaultHeight: number;
  isOpen: boolean;
  onResize: (height: number) => void;
  onClose: () => void;
}

export const useResizablePane = ({
  minHeight,
  maxHeight,
  defaultHeight,
  isOpen,
  onResize,
  onClose,
}: UseResizablePaneProps) => {
  const [height, setHeight] = useState(defaultHeight);
  const paneRef = useRef<HTMLDivElement>(null);
  const isResizing = useRef(false);

  const startResizing = useCallback((e: React.MouseEvent) => {
    isResizing.current = true;
    document.addEventListener('mousemove', resize);
    document.addEventListener('mouseup', stopResizing);
  }, []);

  const resize = useCallback((e: MouseEvent) => {
    if (!isResizing.current) return;
    const newHeight = window.innerHeight - e.clientY;
    if (newHeight >= minHeight && newHeight <= maxHeight) {
      setHeight(newHeight);
      onResize(newHeight);
    }
  }, [minHeight, maxHeight, onResize]);

  const stopResizing = useCallback(() => {
    isResizing.current = false;
    document.removeEventListener('mousemove', resize);
    document.removeEventListener('mouseup', stopResizing);
  }, [resize]);

  useEffect(() => {
    return () => {
      document.removeEventListener('mousemove', resize);
      document.removeEventListener('mouseup', stopResizing);
    };
  }, [resize, stopResizing]);

  return { height, paneRef, startResizing };
};

--- src/shared/hooks/useLocalStorage.ts ---

import { useState, useEffect } from "react";

function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T) => void] {
  // Get from local storage then
  // parse stored json or return initialValue
  const readValue = () => {
    if (typeof window === "undefined") {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  };

  const [storedValue, setStoredValue] = useState<T>(readValue);

  const setValue = (value: T) => {
    try {
      const newValue = value instanceof Function ? value(storedValue) : value;
      window.localStorage.setItem(key, JSON.stringify(newValue));
      setStoredValue(newValue);
    } catch (error) {
      console.warn(`Error setting localStorage key "${key}":`, error);
    }
  };

  useEffect(() => {
    setStoredValue(readValue());
  }, []);

  return [storedValue, setValue];
}

export default useLocalStorage;

--- src/shared/hooks/useDebounce.ts ---

import { useState, useEffect } from 'react';

/**
 * A hook that debounces a value.
 * 
 * @param value The value to be debounced
 * @param delay The delay in milliseconds
 * @returns The debounced value
 */
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Set up a timer to update the debounced value after the specified delay
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Clean up the timer if the value changes before the delay has passed
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}
--- src/shared/hooks/useResizableSidebar.ts ---

import { useState, useCallback, useRef, useEffect } from 'react';

interface UseResizableSidebarProps {
  minWidth: number;
  maxWidth: number;
  defaultWidth: number;
  isOpen: boolean;
  onResize: (width: number) => void;
  onClose: () => void;
  side: 'left' | 'right';
}

export const useResizableSidebar = ({
  minWidth,
  maxWidth,
  defaultWidth,
  isOpen,
  onResize,
  onClose,
  side,
}: UseResizableSidebarProps) => {
  const [width, setWidth] = useState(defaultWidth);
  const sidebarRef = useRef<HTMLDivElement>(null);
  const isResizing = useRef(false);

  const startResizing = useCallback((e: React.MouseEvent) => {
    isResizing.current = true;
    document.addEventListener('mousemove', resize);
    document.addEventListener('mouseup', stopResizing);
  }, []);

  const resize = useCallback((e: MouseEvent) => {
    if (!isResizing.current) return;
    
    let newWidth;
    if (side === 'left') {
      newWidth = e.clientX;
    } else {
      newWidth = window.innerWidth - e.clientX;
    }

    if (newWidth >= minWidth && newWidth <= maxWidth) {
      setWidth(newWidth);
      onResize(newWidth);
    }
  }, [minWidth, maxWidth, onResize, side]);

  const stopResizing = useCallback(() => {
    isResizing.current = false;
    document.removeEventListener('mousemove', resize);
    document.removeEventListener('mouseup', stopResizing);
  }, [resize]);

  useEffect(() => {
    return () => {
      document.removeEventListener('mousemove', resize);
      document.removeEventListener('mouseup', stopResizing);
    };
  }, [resize, stopResizing]);

  return { width, sidebarRef, startResizing };
};
--- src/styles/GlobalStyles.ts ---

import { createGlobalStyle } from 'styled-components';

const GlobalStyles = createGlobalStyle`
  body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  }

  #root {
    height: 100vh;
    width: 100vw;
    overflow: hidden;
  }
`;

export default GlobalStyles;
--- src/styles/common/components.ts ---

import styled from 'styled-components';

export const Button = styled.button`
  background-color: ${({ theme }) => theme.primary};
  color: ${({ theme }) => theme.buttonText};
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s ease;

  &:hover {
    background-color: ${({ theme }) => theme.primaryHover};
  }

  svg {
    margin-right: 0.5rem;
  }
`;

export const Input = styled.input`
  font-size: 16px;
  padding: 0.5rem;
  border: 1px solid ${({ theme }) => theme.border};
  border-radius: 8px;
  background-color: ${({ theme }) => theme.inputBackground};
  color: ${({ theme }) => theme.text};
  transition: border-color 0.3s ease;

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.primary};
  }
`;

export const Card = styled.div`
  background-color: ${({ theme }) => theme.cardBackground};
  border-radius: 12px;
  padding: 1rem;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
`;
--- src/preload.ts ---

import { contextBridge, ipcRenderer } from "electron";
import { Note, FileNode, DirectoryStructures, Embedding, SimilarNote } from "./shared/types";

contextBridge.exposeInMainWorld("electron", {
  saveNote: (note: Note, dirPath: string) =>
    ipcRenderer.invoke("save-note", note, dirPath),
  deleteNote: (noteId: string, dirPath: string) =>
    ipcRenderer.invoke("delete-note", noteId, dirPath),
  minimize: () => ipcRenderer.send("minimize-window"),
  maximize: () => ipcRenderer.send("maximize-window"),
  close: () => ipcRenderer.send("close-window"),
  getNotePath: (noteId: string) => ipcRenderer.invoke("get-note-path", noteId),
  getOpenAIKey: () => ipcRenderer.invoke("get-openai-key"),
  setOpenAIKey: (key: string) => ipcRenderer.invoke("set-openai-key", key),
  createDirectory: (dirPath: string) =>
    ipcRenderer.invoke("create-directory", dirPath),
  deleteDirectory: (dirPath: string) =>
    ipcRenderer.invoke("delete-directory", dirPath),
  getTopLevelFolders: () => ipcRenderer.invoke("get-top-level-folders"),
  addTopLevelFolder: (folderPath: string) =>
    ipcRenderer.invoke("add-top-level-folder", folderPath),
  removeTopLevelFolder: (folderPath: string) =>
    ipcRenderer.invoke("remove-top-level-folder", folderPath),
  openFolderDialog: () => ipcRenderer.invoke("open-folder-dialog"),
  getDirectoryStructure: (dirPath: string) =>
    ipcRenderer.invoke("get-directory-structure", dirPath),
  loadNote: (notePath: string) => ipcRenderer.invoke("load-note", notePath),
  deleteFileNode: (fileNodeType: string, fileNodePath: string) =>
    ipcRenderer.invoke("delete-file-node", fileNodeType, fileNodePath),
  generateNoteEmbeddings: (note: Note, fileNode: FileNode) =>
    ipcRenderer.invoke("generate-note-embeddings", note, fileNode),
  findSimilarNotes: (query: string, directoryStructures: DirectoryStructures) =>
    ipcRenderer.invoke("perform-similarity-search", query, directoryStructures),
});

--- src/main/configManager.ts ---

import { app } from 'electron';
import fs from 'fs/promises';
import path from 'path';

interface Config {
  topLevelFolders: string[];
}

const CONFIG_FILE = path.join(app.getPath('userData'), 'config.json');
console.log(`CONFIG_FILE=${CONFIG_FILE}`)

async function readConfig(): Promise<Config> {
  try {
    const data = await fs.readFile(CONFIG_FILE, 'utf-8');
    const config = JSON.parse(data);
    // Ensure topLevelFolders is always an array
    if (!Array.isArray(config.topLevelFolders)) {
      config.topLevelFolders = [];
    }
    return config;
  } catch (error) {
    console.error('Error reading config:', error);
    // Return default config if file doesn't exist or is invalid
    return { topLevelFolders: [] };
  }
}

async function writeConfig(config: Config): Promise<void> {
  await fs.writeFile(CONFIG_FILE, JSON.stringify(config, null, 2));
}

export async function getTopLevelFolders(): Promise<string[]> {
  const config = await readConfig();
  return config.topLevelFolders;
}

export async function addTopLevelFolder(folderPath: string): Promise<void> {
  const config = await readConfig();
  if (!config.topLevelFolders.includes(folderPath)) {
    config.topLevelFolders.push(folderPath);
    await writeConfig(config);
  }
}

export async function removeTopLevelFolder(folderPath: string): Promise<void> {
  const config = await readConfig();
  config.topLevelFolders = config.topLevelFolders.filter(path => path !== folderPath);
  await writeConfig(config);
}
--- src/main/embeddings.ts ---

import {
  Note,
  FileNode,
  DirectoryStructures,
  Embedding,
  SimilarNote,
} from "@/shared/types";
import { ipcMain } from "electron";
import OpenAI from "openai";
import fs from "fs/promises";
import path from "path";
import { parse } from "node-html-parser";
import { getOpenAIKey } from "./fileSystem";

const TEXT_EMBEDDING_MODEL = "text-embedding-ada-002";

class EmbeddingCreator {
  private openai: OpenAI;

  constructor(openai: OpenAI) {
    this.openai = openai;
  }

  async createEmbedding(content: string): Promise<Embedding> {
    return await this.openai.embeddings.create({
      model: TEXT_EMBEDDING_MODEL,
      input: content,
    });
  }

  async parseNoteForEmbedding(note: Note): Promise<string> {
    const root = parse(note.content);
    const textContent = root.textContent.trim();
    return `${note.title}\n\n${textContent}`;
  }

  async saveEmbedding(embedding: Embedding, filePath: string): Promise<void> {
    const embeddingDirPath = path.dirname(filePath);
    await fs.mkdir(embeddingDirPath, { recursive: true });
    await fs.writeFile(filePath, JSON.stringify(embedding));
  }
}

class SimilaritySearcher {
  async findEmbeddingPaths(
    directoryStructures: DirectoryStructures
  ): Promise<string[]> {
    const embeddingPaths: string[] = [];

    const traverseStructure = async (fileNode: FileNode) => {
      if (fileNode.type === "note" && fileNode.noteMetadata) {
        const embeddingPath = `${path.dirname(fileNode.fullPath)}/${
          fileNode.noteMetadata.id
        }.embedding.json`;
        try {
          await fs.access(embeddingPath);
          embeddingPaths.push(embeddingPath);
        } catch (error) {
          // Embedding file doesn't exist, skip
        }
      }
      if (fileNode.childIds) {
        for (const childId of fileNode.childIds) {
          const childNode = directoryStructures.nodes[childId];
          if (childNode) {
            await traverseStructure(childNode);
          }
        }
      }
    };

    for (const rootId of directoryStructures.rootIds) {
      const rootNode = directoryStructures.nodes[rootId];
      if (rootNode) {
        await traverseStructure(rootNode);
      }
    }

    return embeddingPaths;
  }

  async performSimilaritySearch(
    queryEmbedding: OpenAI.Embeddings.CreateEmbeddingResponse,
    embeddingPaths: string[]
  ): Promise<SimilarNote[]> {
    const results: SimilarNote[] = [];

    for (const embeddingPath of embeddingPaths) {
      const embeddingContent = await fs.readFile(embeddingPath, "utf-8");
      const embedding = JSON.parse(embeddingContent) as Embedding;
      const score = this.cosineSimilarity(
        queryEmbedding.data[0].embedding,
        embedding.data[0].embedding
      );
      const notePath = embeddingPath.replace(".embedding.json", ".json");
      const noteContent = await fs.readFile(notePath, "utf-8");
      const note = JSON.parse(noteContent) as SimilarNote;

      results.push({ ...note, score });
    }

    return results.sort((a, b) => b.score - a.score).slice(0, 5); // Return top 5 results
  }

  cosineSimilarity(a: number[], b: number[]): number {
    const dotProduct = a.reduce((sum, _, i) => sum + a[i] * b[i], 0);
    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (magnitudeA * magnitudeB);
  }
}

export const setupEmbeddingService = async (): Promise<void> => {
  const openaiApiKey = await getOpenAIKey();
  const openai = new OpenAI({ apiKey: openaiApiKey });
  const embeddingCreator = new EmbeddingCreator(openai);
  const similaritySearcher = new SimilaritySearcher();

  ipcMain.handle(
    "generate-note-embeddings",
    async (_, note: Note, fileNode: FileNode): Promise<Embedding> => {
      try {
        const parsedContent = await embeddingCreator.parseNoteForEmbedding(note);
        const embedding = await embeddingCreator.createEmbedding(parsedContent);
        const embeddingFullPath = path.join(
          path.dirname(fileNode.fullPath),
          `${note.id}.embedding.json`
        );
        await embeddingCreator.saveEmbedding(embedding, embeddingFullPath);
        return embedding;
      } catch (error) {
        console.error("Error generating note embeddings:", error);
        throw error;
      }
    }
  );

  ipcMain.handle(
    "perform-similarity-search",
    async (
      _,
      query: string,
      directoryStructures: DirectoryStructures
    ): Promise<SimilarNote[]> => {
      try {
        const queryEmbedding = await embeddingCreator.createEmbedding(query);
        const embeddingPaths = await similaritySearcher.findEmbeddingPaths(
          directoryStructures
        );
        return await similaritySearcher.performSimilaritySearch(
          queryEmbedding,
          embeddingPaths
        );
      } catch (error) {
        console.error("Error performing similarity search:", error);
        throw error;
      }
    }
  );
};

--- src/main/pythonBridge.ts ---

import { PythonShell } from "python-shell";
import path from "path";
import { app } from "electron";
import fs from "fs";
import { getOpenAIKey, NOTES_DIR } from "./fileSystem";

export function runPythonScript(
  scriptName: string,
  args: string[] = [],
  env: Record<string, string> = {}
): Promise<any> {
  return new Promise((resolve, reject) => {
    let scriptPath: string;
    let pythonPath: string;

    if (app.isPackaged) {
      scriptPath = path.join(
        process.resourcesPath,
        "src",
        "python",
        "services",
        `${scriptName}.py`
      );
      pythonPath = path.join(
        process.resourcesPath,
        "python_venv",
        "Scripts",
        "python.exe"
      );
    } else {
      scriptPath = path.join(
        app.getAppPath(),
        "src",
        "python",
        "services",
        `${scriptName}.py`
      );
      pythonPath = path.join(
        app.getAppPath(),
        "python_venv",
        "Scripts",
        "python.exe"
      );
    }

    if (process.platform !== "win32") {
      pythonPath = pythonPath.replace("Scripts", "bin").replace(".exe", "");
    }

    console.log("Attempting to run Python script at:", scriptPath);
    console.log("Using Python interpreter at:", pythonPath);

    if (!fs.existsSync(scriptPath)) {
      console.error("Python script not found at:", scriptPath);
      reject(new Error(`Python script not found: ${scriptPath}`));
      return;
    }

    PythonShell.run(scriptPath, { pythonPath, args, env })
      .then((results) => {
        console.log("Python script results:", results);
        resolve(JSON.parse(results[0]));
      })
      .catch((err) => {
        console.error("Error running Python script:", err);
        reject(err);
      });
  });
}

export async function runEmbeddingScript(
  action: string,
  ...args: string[]
): Promise<any> {
  const apiKey = await getOpenAIKey();

  console.log({
    embeddings: "embeddings",
    action,
    ...args,
    OPEN_AI_API_KEY: apiKey
  })

  return runPythonScript("embeddings", [action, ...args], {
    OPENAI_API_KEY: apiKey,
  });
}

--- src/main/fileSystem.ts ---

import { ipcMain, app } from "electron";
import fs from "fs/promises";
import path from "path";
import { Config, DirectoryEntry, Note, NoteMetadata } from "@/shared/types";
import { v4 as uuidv4 } from "uuid";

const NOTES_DIR = path.join(app.getPath("userData"), "notes");

// Special delimiter used for parsing notes from non-notes
const NOTE_DELIMITER = "___";

// Create a config file path
const CONFIG_FILE = path.join(app.getPath("userData"), "config.json");

export const setupFileSystem = async () => {
  // Ensure the notes directory exists
  await fs.mkdir(NOTES_DIR, { recursive: true });

  // Ensure the config file exists
  try {
    await fs.access(CONFIG_FILE);
  } catch {
    await fs.writeFile(CONFIG_FILE, JSON.stringify({}));
  }

  ipcMain.handle("get-directory-structure", async (_, dirPath: string) => {
    try {
      const dirStructure = await loadDirectoryStructure(dirPath);
      return dirStructure;
    } catch (error) {
      console.error(`Error loading directory structure for dirPath=${dirPath}`);
      throw error;
    }
  });

  ipcMain.handle("load-note", async (_, notePath: string) => {
    try {
      const noteContent = await fs.readFile(notePath, "utf-8");
      const note: Note = JSON.parse(noteContent);
      return note;
    } catch (error) {
      console.error("Error loading note:", error);
      throw error;
    }
  });

  ipcMain.handle("save-note", async (_, note: Note, dirPath: string) => {
    try {
      const fileName = `${note.id}.json`;
      const filePath = path.join(dirPath, fileName);
      await fs.mkdir(dirPath, { recursive: true });
      await fs.writeFile(filePath, JSON.stringify(note));
      console.log(`Note saved successfully at filePath=${filePath}`);
      return filePath;
    } catch (error) {
      console.error("Error saving note:", error);
      throw error;
    }
  });

  ipcMain.handle("delete-file-node", async (_, fileNodeType: string, fileNodePath: string) => {
  try {
    if (fileNodeType === "directory") {
      // Deletes the directory and all its contents, including embedding files
      await fs.rm(fileNodePath, { recursive: true, force: true });
    } else if (fileNodeType === "note") {
      // Delete the note file
      await fs.unlink(fileNodePath);

      // Construct the embedding file path
      const embeddingFilePath = fileNodePath.replace(/\.json$/, ".embedding.json");

      // Attempt to delete the embedding file
      try {
        await fs.unlink(embeddingFilePath);
        console.log(`Embedding file deleted at path: ${embeddingFilePath}`);
      } catch (error: any) {
        if (error.code !== "ENOENT") {
          // Log errors other than file not existing
          console.error(`Error deleting embedding file at path: ${embeddingFilePath}`, error);
        }
        // If the embedding file doesn't exist, ignore the error
      }
    }
  } catch (err) {
    console.error(`Error deleting fileNode with path: ${fileNodePath}`, err);
  }
  });


  ipcMain.handle("create-directory", async (_, dirPath: string) => {
    try {
      await fs.mkdir(dirPath, { recursive: true });
    } catch (error) {
      console.error("Error creating directory:", error);
      throw error;
    }
  });

  ipcMain.handle("delete-directory", async (_, dirPath: string) => {
    try {
      await fs.rm(dirPath, { recursive: true, force: true });
    } catch (error) {
      console.error("Error deleting directory:", error);
      throw error;
    }
  });

  ipcMain.handle("get-note-path", async (_, noteId: string) => {
    return path.join(NOTES_DIR, `${noteId}.json`);
  });

  ipcMain.handle("get-openai-key", async () => {
    try {
      const config = await fs.readFile(CONFIG_FILE, "utf-8");
      return JSON.parse(config).openaiApiKey || "";
    } catch (error) {
      console.error("Error reading OpenAI API key:", error);
      return "";
    }
  });

  ipcMain.handle("set-openai-key", async (_, key: string) => {
    try {
      let config: Config = {};
      try {
        const configContent = await fs.readFile(CONFIG_FILE, "utf-8");
        config = JSON.parse(configContent);
      } catch (error) {
        // If the file doesn't exist or is invalid, start with an empty config
        config = {};
      }
      config.openaiApiKey = key;
      await fs.writeFile(CONFIG_FILE, JSON.stringify(config, null, 2));
    } catch (error) {
      console.error("Error saving OpenAI API key:", error);
      throw error;
    }
  });
};

// Recursively create a tree representation of a directory
const loadDirectoryStructure = async (dirPath: string): Promise<DirectoryEntry> => {
  const dirName = path.basename(dirPath);
  const structure: DirectoryEntry = {
    name: dirName,
    type: "directory",
    fullPath: dirPath,
    children: [],
  };

  const entries = await fs.readdir(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const childPath = path.join(dirPath, entry.name);

    if (entry.isDirectory()) {
      const childStructure = await loadDirectoryStructure(childPath);
      structure.children?.push(childStructure);
    } else if (
      entry.isFile() &&
      entry.name.endsWith(".json") &&
      !entry.name.endsWith(".embedding.json")
    ) {
      try {
        const noteContent = await fs.readFile(childPath, "utf-8");
        const note: Note = JSON.parse(noteContent);
        structure.children?.push({
          name: note.title,
          type: "note",
          noteMetadata: {
            id: note.id,
            title: note.title,
          },
          fullPath: childPath,
        });
      } catch (error) {
        console.error(`Error reading note file ${childPath}:`, error);
      }
    }
  }

  return structure;
};

export const getOpenAIKey = async (): Promise<string> => {
  try {
    const configContent = await fs.readFile(CONFIG_FILE, "utf-8");
    const config = JSON.parse(configContent);
    return config.openaiApiKey || "";
  } catch (error) {
    console.error("Error reading OpenAI API key:", error);
    return "";
  }
};
